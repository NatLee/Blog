<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nat&#39;s blog</title>
  
  <subtitle>Inspire with nothing.</subtitle>
  <link href="http://natlee.github.io/Blog/atom.xml" rel="self"/>
  
  <link href="http://natlee.github.io/Blog/"/>
  <updated>2022-02-10T00:25:59.902Z</updated>
  <id>http://natlee.github.io/Blog/</id>
  
  <author>
    <name>Nat Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用docker container建立SSH反向通道穿透內網連接內部裝置</title>
    <link href="http://natlee.github.io/Blog/posts/509187850/"/>
    <id>http://natlee.github.io/Blog/posts/509187850/</id>
    <published>2022-02-08T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>之前一直很想寫反向通道的流程，但過程很難描述</p><p>剛好最近在docker上看到好用的openssh-server的image</p><p>結果一試就上手，於是就有這篇文章了</p><span id="more"></span><h2 id="步驟說明"><a href="#步驟說明" class="headerlink" title="步驟說明"></a>步驟說明</h2><hr><p>首先，你需要一個<code>位於外網且可以透過SSH連線的裝置</code></p><p>如果沒有，請按上一頁</p><p><img src="https://raw.githubusercontent.com/linuxserver/docker-templates/master/linuxserver.io/img/linuxserver_medium.png"></p><p>我今天看到一個image <span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL2xpbnV4c2VydmVyL29wZW5zc2gtc2VydmVy">linuxserver/openssh-server<i class="fa fa-external-link-alt"></i></span></p><p>它把openssh-server的部分都做好了</p><p>所以我們可以直接用這個image去run一個container</p><p>也就是寫一份docker-compose的文件就搞定了</p><p>接下來，我們會分別討論三個裝置上的設定</p><ul><li>外網裝置 A</li><li>內網跳板裝置 B</li><li>透過跳板B連至內網裝置C</li></ul><h3 id="外網裝置-A"><a href="#外網裝置-A" class="headerlink" title="外網裝置 A"></a>外網裝置 A</h3><p>首先，我們先在外網的機器A先佈置能能夠進行被反向連接的server</p><p>我們基於docker hub上面官方的文件做修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openssh-server:</span></span><br><span class="line">   <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">lscr.io/linuxserver/openssh-server</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">reverse-tunnel-outside-server</span></span><br><span class="line">   <span class="attr">hostname:</span> <span class="string">nat-tunnel-outside-server</span> <span class="comment">#optional</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">TZ=Asia/Taipei</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY=yourpublickey #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_FILE=/path/to/file #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_DIR=/config/.ssh #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_URL=https://github.com/username.keys #optional</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">SUDO_ACCESS=true</span> <span class="comment">#optional</span></span><br><span class="line">    <span class="comment">#- PASSWORD_ACCESS=false #optional</span></span><br><span class="line">    <span class="comment">#- USER_PASSWORD=password #optional</span></span><br><span class="line">    <span class="comment">#- USER_PASSWORD_FILE=/path/to/file #optional</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_NAME=natlee</span> <span class="comment">#optional</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./ssh_setting:/config</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./root_ssh_setting:/root/.ssh</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">1984</span><span class="string">:2222</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">1994</span><span class="string">:1994</span></span><br></pre></td></tr></table></figure><p>主要比較有意義的改動是<code>volumes</code>跟<code>port</code></p><blockquote><p>有些版本的docker會出現無法binding volumes的問題，可以先自己用<code>mkdir</code>建立資料夾</p></blockquote><p>因爲它的image包好的SSH port是<code>2222</code>，那麼我們把外部<code>1984</code>對應進去</p><p>另外，我們需要多開一個port讓內網裏面做反向的裝置能夠連到這臺server</p><p>所以多開了一個port <code>1994</code></p><blockquote><p>這邊記得在路由器幫這兩個port做forwarding，建議內外相同port就行了</p></blockquote><p>接着，我們就執行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>記得，這邊沒有使用<code>-d</code>去做背景執行</p><p>我們需要修改openssh-server的設定檔<code>sshd_config</code></p><p>打開剛剛指定目錄中的<code>./ssh_setting/ssh_host_keys/sshd_config</code>去把這設定改成<code>yes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AllowTCPForwarding yes</span><br><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure><p>重新執行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --force-recreate</span><br></pre></td></tr></table></figure><p>我們這時候可以用local做連線測試</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh natlee@localhost -p 1984                          </span><br><span class="line">The authenticity of host <span class="string">&#x27;[localhost]:2000 ([::1]:1984)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:g73WW30kTFqdUvi/mCbIgrW4dnadPiW7ipopK9h6/zk.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>[localhost]:1984<span class="string">&#x27; (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">natlee@localhost: Permission denied (publickey,keyboard-interactive).</span></span><br></pre></td></tr></table></figure><p>於是，失敗了，因爲我們只能用key進行連線！</p><p>那麼要如何測試連線呢？</p><p>我們先找一對金鑰（如果沒有的話，可以用<code>ssh-keygen</code>生成）</p><p>再把剛找的公鑰（通常預設會在<code>~/.ssh/id_rsa.pub</code>）放到<code>./ssh_setting/.ssh/authorized_keys</code>內</p><p>內容類似長這樣的東西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDs13dOFtSQ8OJjIIZiVKWTIUbEvy+ZIcswOiXCb4q4nIK80yNyuDOVcbzQyyS0Q0z0UUTpf+TR5Rs4Ox0B8baffTC0CvFHQhwqpgvz/8d179fmUCyDb9yrdgdhSlN4zkMdw8A2P8SQ+3cc+gIQBvj/jo414kynz4zaoGseFxBOpVKc+dW1Y8m3G4wfBB0QpcyxYZ9vkAhrIYyPrIK9EP7LXTlJyQ7gMadJ4eUkMiBSnqfJYxPcYDIeK/uHYyGgpsJQUaxZ8JIqkD2kdmBPX8NHGA1O2VF2UyiJKuRVJEg/oW7YoCJHs81Gj+bl9HdnBC5CEMWckLPLRtfFkW3u9F6PNto9fs48L1dU8MGm6KAirX2GPydmwRS6yh9i32NT5J70izi28cX1IhJn2PtY75aZAPuU2NspsJ1cy4cbd35tJLB0H0= root@test</span><br></pre></td></tr></table></figure><p>再用SSH連線一次！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh natlee@localhost -p 1984                      </span><br><span class="line">Welcome to OpenSSH Server</span><br><span class="line"></span><br><span class="line">nat-tunnel-outside-server:~$</span><br></pre></td></tr></table></figure><p>到這邊算是外網機器佈置成功了！</p><p>執行中的時候，內容物長這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── root_ssh_setting</span><br><span class="line">└── ssh_setting</span><br><span class="line">    ├── custom-cont-init.d</span><br><span class="line">    ├── custom-services.d</span><br><span class="line">    ├── logs</span><br><span class="line">    │   ├── loginfo.txt</span><br><span class="line">    │   └── openssh</span><br><span class="line">    │       ├── current</span><br><span class="line">    │       ├── lock</span><br><span class="line">    │       └── state</span><br><span class="line">    ├── sshd.pid</span><br><span class="line">    └── ssh_host_keys</span><br><span class="line">        ├── sshd_config</span><br><span class="line">        ├── ssh_host_dsa_key</span><br><span class="line">        ├── ssh_host_dsa_key.pub</span><br><span class="line">        ├── ssh_host_ecdsa_key</span><br><span class="line">        ├── ssh_host_ecdsa_key.pub</span><br><span class="line">        ├── ssh_host_ed25519_key</span><br><span class="line">        ├── ssh_host_ed25519_key.pub</span><br><span class="line">        ├── ssh_host_rsa_key</span><br><span class="line">        └── ssh_host_rsa_key.pub</span><br><span class="line"></span><br><span class="line">7 directories, 15 files</span><br></pre></td></tr></table></figure><h3 id="內網跳板裝置-B"><a href="#內網跳板裝置-B" class="headerlink" title="內網跳板裝置 B"></a>內網跳板裝置 B</h3><p>內網裝置需要的東西就比較多了</p><p>但還是老樣子，我們再起一個openssh-server</p><p>基於docker hub上面官方的文件做修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openssh-server:</span></span><br><span class="line">   <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">lscr.io/linuxserver/openssh-server</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">reverse-tunnel-inside-bridge</span></span><br><span class="line">   <span class="attr">hostname:</span> <span class="string">nat-tunnel-inside-bridge</span> <span class="comment">#optional</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">PUID=1000</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">PGID=1000</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">TZ=Asia/Taipei</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY=yourpublickey #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_FILE=/path/to/file #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_DIR=/config/.ssh #optional</span></span><br><span class="line">    <span class="comment">#- PUBLIC_KEY_URL=https://github.com/username.keys #optional</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">SUDO_ACCESS=true</span> <span class="comment">#optional</span></span><br><span class="line">    <span class="comment">#- PASSWORD_ACCESS=false #optional</span></span><br><span class="line">    <span class="comment">#- USER_PASSWORD=password #optional</span></span><br><span class="line">    <span class="comment">#- USER_PASSWORD_FILE=/path/to/file #optional</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">USER_NAME=natlee</span> <span class="comment">#optional</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./ssh_setting:/config</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./root_ssh_setting:/root/.ssh</span></span><br></pre></td></tr></table></figure><p>改完之後直接run一波</p><blockquote><p>有些版本的docker會出現無法binding volumes的問題，可以先自己用<code>mkdir</code>建立資料夾</p></blockquote><p>內網的裝置就不用給ports，給了也只有內網電腦能連進去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>run完會看到它的啓動畫面，然後就跟剛剛一樣生一堆文件出來</p><p>我們接下來要配置一些文件讓它能夠連到server且斷線後能夠重連</p><ul><li><p>建立安裝autossh的腳本</p><p>  使用<code>sudo nano ./ssh_setting/custom-cont-init.d/install.sh</code>將以下內容貼上</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apk add --no-cache autossh</span><br></pre></td></tr></table></figure></li><li><p>建立啓動autossh的腳本</p><p>  使用<code>sudo nano ./ssh_setting/custom-services.d/autossh.sh</code>將以下內容貼上</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start AutoSSH&quot;</span></span><br><span class="line">autossh \</span><br><span class="line"> -p 1984 \</span><br><span class="line"> -M 0 \</span><br><span class="line"> -NR <span class="string">&#x27;*:1994:localhost:2222&#x27;</span> \</span><br><span class="line"> natlee@&lt;EXAMPLE_DOMAIN&gt; \</span><br><span class="line"> -i ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>  這邊請把<code>&lt;EXAMPLE_DOMAIN&gt;</code>改成你自己連接外網裝置的domain或IP</p></li></ul><p>接着，我們直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>然後就噴錯了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse-tunnel-inside-bridge | Warning: Identity file /root/.ssh/id_rsa not accessible: No such file or directory.</span><br><span class="line">reverse-tunnel-inside-bridge | Host key verification failed.</span><br></pre></td></tr></table></figure><p>爲什麼它會說無法存取<code>/root/.ssh/id_rsa</code>？</p><p>因爲它必須要靠key來連到server，但它並沒有key pairs</p><p>所以我們得幫他產生一組</p><p>我們先別暫停container，而是直接使用這個指令進去container內</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it reverse-tunnel-inside-bridge /bin/bash</span><br></pre></td></tr></table></figure><p>然後使用以下指令產生公私鑰對</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@nat-tunnel-inside-bridge:/<span class="comment"># ssh-key</span></span><br><span class="line">ssh-keygen   ssh-keyscan</span><br><span class="line">root@nat-tunnel-inside-bridge:/<span class="comment"># ssh-keygen</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:YYaMzm7rD4dAQlREdwzOMufrbe5KLwc1z554ePFIvsc root@nat-tunnel-inside-bridge</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|.o++ oo.         |</span></span><br><span class="line"><span class="string">|.   +o.o         |</span></span><br><span class="line"><span class="string">|. .o.+o +        |</span></span><br><span class="line"><span class="string">| o o=  = .       |</span></span><br><span class="line"><span class="string">|  . o.. S        |</span></span><br><span class="line"><span class="string">|   o o.  =       |</span></span><br><span class="line"><span class="string">|    =oo * *      |</span></span><br><span class="line"><span class="string">|   .o=o= B E     |</span></span><br><span class="line"><span class="string">|   .o+O=o.o      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>我們就可以把公鑰檔案<code>~/.ssh/id_rsa.pub</code>的內容複製出來</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@nat-tunnel-inside-bridge:/<span class="comment"># cat ~/.ssh/id_rsa.pub</span></span><br><span class="line">ssh-rsa AAAAB3NzaC...............bZVysfXr9E= root@nat-tunnel-inside-bridge</span><br></pre></td></tr></table></figure><p>把焦點轉回剛剛的container輸出會看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse-tunnel-inside-bridge | Start AutoSSH</span><br><span class="line">reverse-tunnel-inside-bridge | Host key verification failed.</span><br></pre></td></tr></table></figure><p>這邊就節省麻煩，我們直接進到內網裝置B的container訪問一次server</p><p>先把剛剛的公鑰複製到我們外網server的<code>./ssh_setting/.ssh/authorized_keys</code>中</p><p>在B的container內用以下指令訪問一次server，並輸入<code>yes</code>去記錄host</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@nat-tunnel-inside-bridge:/<span class="comment"># ssh natlee@&lt;EXAMPLE_DOMAIN&gt; -p 1984</span></span><br><span class="line">The authenticity of host <span class="string">&#x27;[EXAMPLE_DOMAIN]:1984 ([XXX.XXX.XXX.XXX]:1984)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ED25519 key fingerprint is SHA256:JNKQF+GwAgca6xPeoz2ROfz6WXe2oo7HepwuemJH58M.</span></span><br><span class="line"><span class="string">This key is not known by any other names</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>[EXAMPLE_DOMAIN]:1984<span class="string">&#x27; (ED25519) to the list of known hosts.</span></span><br><span class="line"><span class="string">Welcome to OpenSSH Server</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nat-tunnel-server:~$</span></span><br></pre></td></tr></table></figure><p>這時候看回去container輸出就沒有再跳錯誤了！</p><p>到這邊內網裝置B已經算是設定完成了</p><p>接下來，我們把自己PC的公鑰複製到內網裝置的<code>ssh_setting/.ssh/authorized_keys</code>後，重新執行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --force-recreate</span><br></pre></td></tr></table></figure><p>再來，我們從PC端使用SSH連接server的另外一個port <code>1994</code>去做測試</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh natlee@&lt;EXAMPLE_DOMAIN&gt; -p 1994</span><br><span class="line">Welcome to OpenSSH Server</span><br><span class="line"></span><br><span class="line">nat-tunnel-inside-bridge:~$</span><br></pre></td></tr></table></figure><p>連到裝置B，也就是成功打洞進到內網了！</p><h3 id="透過跳板B連至內網裝置C"><a href="#透過跳板B連至內網裝置C" class="headerlink" title="透過跳板B連至內網裝置C"></a>透過跳板B連至內網裝置C</h3><p>這邊的裝置C，我使用樹莓派當範例</p><p>我們可以利用<code>~/.ssh/config</code>去設定SSH的快速連線方式，如下面的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Host reverse-tunnel-outside-server</span><br><span class="line">    HostName &lt;EXAMPLE_DOMAIN&gt;</span><br><span class="line">    User natlee</span><br><span class="line">    port 1984</span><br><span class="line">    Compression yes</span><br><span class="line"></span><br><span class="line">Host reverse-tunnel-inside-bridge</span><br><span class="line">    HostName &lt;EXAMPLE_DOMAIN&gt;</span><br><span class="line">    User natlee</span><br><span class="line">    port 1994</span><br><span class="line">    Compression yes</span><br><span class="line"></span><br><span class="line">Host pi-reversed</span><br><span class="line">    HostName 192.168.1.87</span><br><span class="line">    User pi</span><br><span class="line">    port 22</span><br><span class="line">    Compression yes</span><br><span class="line">    ProxyCommand ssh -W %h:%p reverse-tunnel-inside-bridge</span><br></pre></td></tr></table></figure><p>第一個host，我們可以連到外網server A，也就是port爲<code>1984</code>的那位</p><p>第二個host，我們可以連到內網裝置B，也就是經過反向後，port爲<code>1994</code>的那位</p><p>最重要的是第三個host，裏面這句<code>ProxyCommand ssh -W %h:%p reverse-tunnel-inside-bridge</code>是精髓</p><p>意思是透過第二個host <code>reverse-tunnel-inside-bridge</code> 進行proxy連到區網的位置 <code>192.168.1.87</code></p><p>有了這個快速連線法，我們就可以直接來體驗一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh pi-reversed</span><br><span class="line">Linux raspberrypi 5.10.17-v7l+ <span class="comment">#1421 SMP Thu May 27 14:00:13 BST 2021 armv7l</span></span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Thu Feb 10 01:17:55 2022 from 192.168.1.133</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這樣配置之後，我們很簡單就可以直接從外網穿透到其他內部機器上了！</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇實驗做滿久的，不過從頭跑一次整個流程之後，我也對打洞有更深一步的認識</p><p>打洞的好處很多，像是vscode可以使用remote-ssh的套件</p><p>我們就可以直接選擇<code>./ssh/config</code>內的機器進行連線</p><p>而且SFTP也是走SSH通道，我們可以直接在外網做內網檔案的傳輸</p><p>甚至我們也可以直接用內網做proxy來瀏覽內部才能看的網站</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><span class="exturl" data-url="aHR0cDovL2Fyb25kaWdodC5tZS8yMDE2LzAyLzE3LyVFNCVCRCVCRiVFNyU5NCVBOFNTSCVFNSU4RiU4RCVFNSU5MCU5MSVFOSU5QSVBNyVFOSU4MSU5MyVFOCVCRiU5QiVFOCVBMSU4QyVFNSU4NiU4NSVFNyVCRCU5MSVFNyVBOSVCRiVFOSU4MCU4Ri8=">使用SSH反向隧道进行内网穿透<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZXZlcnl0aGluZ2NsaS5vcmcvc3NoLXR1bm5lbGxpbmctZm9yLWZ1bi1hbmQtcHJvZml0LWF1dG9zc2gv">SSH TUNNELLING FOR FUN AND PROFIT: AUTOSSH<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;之前一直很想寫反向通道的流程，但過程很難描述&lt;/p&gt;
&lt;p&gt;剛好最近在docker上看到好用的openssh-server的image&lt;/p&gt;
&lt;p&gt;結果一試就上手，於是就有這篇文章了&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/categories/blog/"/>
    
    
    <category term="docker" scheme="http://natlee.github.io/Blog/tags/docker/"/>
    
    <category term="container" scheme="http://natlee.github.io/Blog/tags/container/"/>
    
    <category term="ssh" scheme="http://natlee.github.io/Blog/tags/ssh/"/>
    
    <category term="tunnel" scheme="http://natlee.github.io/Blog/tags/tunnel/"/>
    
  </entry>
  
  <entry>
    <title>PKCS#1中RSA的加解密填充圖解（v1_5跟OAEP）</title>
    <link href="http://natlee.github.io/Blog/posts/833732900/"/>
    <id>http://natlee.github.io/Blog/posts/833732900/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>這篇算是之前資安常識裏面提到RSA加密的延伸補充。</p><p>我們說的RSA加密不是單純只有加密，還必須加料。</p><p>這樣才能夠有一定的混淆性。</p><p>這邊記錄一下PKCS#1裏面定義的RSA加解密流程。</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><p>下面部分內容會從PKCS#1中節錄，但這邊只討論加解密，並不會談到簽驗章流程。</p><h3 id="RSA-Cryptography-Specifications"><a href="#RSA-Cryptography-Specifications" class="headerlink" title="RSA Cryptography Specifications"></a>RSA Cryptography Specifications</h3><hr><h4 id="Key-Types"><a href="#Key-Types" class="headerlink" title="Key Types"></a>Key Types</h4><hr><p>這邊寫在PKCS#1裏面的Sec.3。</p><p>我們知道RSA是非對稱加密，然後會產生兩把鑰匙，一把是公鑰，另一把則是私鑰。</p><p>但是，平常在加解密的時候，我們要怎麼知道到底哪個是私鑰？哪個是公鑰？</p><p>在PKCS#1裏面就有分別定義公鑰跟私鑰的長相。</p><ul><li><p>公鑰（Public Key）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSAPublicKey ::= SEQUENCE &#123;</span><br><span class="line"> modulus INTEGER, -- n</span><br><span class="line"> publicExponent INTEGER -- e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  這裏面有兩個參數，分別是modulus跟publicExponent。</p><p>  就是我們熟知的公鑰(N, e)。</p><p>  其中，N是兩個質數p、q相乘。<br>  那麼，e是根據費馬小定理去計算：</p><blockquote><p>r = ɸ(N) = ɸ(p) ɸ(q) = (p-1)(q-1)</p></blockquote><p>  然後，找一個小於 r 且互質的整數，就是e。</p><p>  這個e通常是<code>65537</code>，因爲安全性問題。</p><p>  可以看看<span class="exturl" data-url="aHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxMTAvaW1wYWN0cy1vZi1ub3QtdXNpbmctcnNhLWV4cG9uZW50LW9mLTY1NTM3LzMxMTM=">這邊<i class="fa fa-external-link-alt"></i></span>的解釋。</p></li><li><p>私鑰（Private Key）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RSAPrivateKey ::= SEQUENCE &#123;</span><br><span class="line"> version Version,</span><br><span class="line"> modulus INTEGER, -- n</span><br><span class="line"> publicExponent INTEGER, -- e</span><br><span class="line"> privateExponent INTEGER, -- d</span><br><span class="line"> prime1 INTEGER, -- p</span><br><span class="line"> prime2 INTEGER, -- q</span><br><span class="line"> exponent1 INTEGER, -- d mod (p-<span class="number">1</span>)</span><br><span class="line"> exponent2 INTEGER, -- d mod (q-<span class="number">1</span>)</span><br><span class="line"> coefficient INTEGER -- (inverse <span class="keyword">of</span> q) mod p</span><br><span class="line"> otherPrimeInfos OtherPrimeInfos OPTIONAL</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">Version</span> ::= INTEGER</span><br></pre></td></tr></table></figure><p>  從定義裏面，我們可以看到私鑰裏面裝得東西超級多。</p><p>  除了使用的版本(version)外，還有剛剛我們提到的公鑰，沒錯私鑰裏面也有公鑰(N, e)。</p><p>  裏面還有私鑰的d跟組成N的p、q。</p><p>  這邊除了這些東西外，還有一些神奇的定義就是exponent1、exponent2、coefficient跟otherPrimeInfos。</p><p>  otherPrimeInfos還好理解，就是有關質數的一些其他資訊。</p><p>  但其他的項目是什麼作用呢？</p><p>  就是一種建表的方式，有些東西先算好寫好，避免日後運算再花時間。</p></li></ul><h4 id="Data-Conversion-Primitives"><a href="#Data-Conversion-Primitives" class="headerlink" title="Data Conversion Primitives"></a>Data Conversion Primitives</h4><hr><p>這邊的內容在PKCS#1的Sec.4。</p><p>主要內容是定義函數，介紹數字跟二進位文字（可以說是binary string）的互轉。</p><p>學海無涯，這邊推廣一下python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這樣就可以表示binary string了</span></span><br><span class="line"><span class="string">b&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure><p>Binary string也可以說是octet string或是byte string。</p><p>聽說會取名<code>octet</code>是因爲很容易跟<code>byte</code>搞混。</p><p>Octet string的範例 -&gt; <code>af:ec:ec:8a:f4:09:52:53:69:d4:da:54</code></p><p>那爲什麼要轉來轉去？</p><p>答案是因爲RSA是數學運算，那文字沒辦法直接計算加密，我們得轉成數字才能計算。</p><h5 id="I2OSP"><a href="#I2OSP" class="headerlink" title="I2OSP"></a>I2OSP</h5><p>Integer-to-Octet-String primitive<br>數字轉文字</p><blockquote><p><strong>I2OSP(x, L)</strong><br>x: nonnegative integer, but less than 256^L.<br>L: octet string 的字節長度(length)，一個字節是8-bit。</p><blockquote><p>這邊有個範例<br>I2OSP(4095, 2) = 0F:FF</p></blockquote></blockquote><h5 id="OS2IP"><a href="#OS2IP" class="headerlink" title="OS2IP"></a>OS2IP</h5><p>Octet-String-to-Integer primitive<br>文字轉數字</p><blockquote><p><strong>OS2IP(X)</strong><br>X: octet string，出來的輸出就是按照位數進行二進位值的相加。</p><blockquote><p>這邊有個範例<br>OS2IP(0F:FF) = 4095（因爲<code>0x0FFF = 0000 1111 1111 1111</code>）</p></blockquote></blockquote><h4 id="Cryptographic-Primitives"><a href="#Cryptographic-Primitives" class="headerlink" title="Cryptographic Primitives"></a>Cryptographic Primitives</h4><hr><p>這邊定義在PKCS#1的Sec.5。</p><p>這節主要是定義加解密的函數，分別有公私鑰應用在加解密的狀況。</p><p>畢竟PKCS本身就是個大定義，它爲了後面不再敘述這些東西，這些函數就當成一個箱子，東西放進去，結果就出來了。</p><p>在密碼學上面，只要你引用了PKCS，除非你是RSA其中一位，不然這世界上幾乎沒有人可以再質疑你。</p><ul><li>公鑰加密 RSAEP ((n, e), m) </li><li>私鑰解密 RSADP (K, c)</li><li>私鑰簽章 RSASP1 (K, m)</li><li>公鑰驗章 RSAVP1 ((n, e), s)</li></ul><p>其中，m就是message，c就是cipher，K是私鑰，s是signature。</p><p>不過這篇文章只會講加解密，並不會談到簽章的部分。</p><p>那麼，上面有應用到私鑰解密的部分，可以使用中國餘式定理的解法以加速運算。</p><h5 id="中國餘式定理加速運算"><a href="#中國餘式定理加速運算" class="headerlink" title="中國餘式定理加速運算"></a>中國餘式定理加速運算</h5><p>我們知道明文<code>m = c^d mod n</code>，<code>c</code>是密文，<code>d</code>是私鑰組成的其中一個元素，<code>n</code>則是兩個大質數<code>p</code>跟<code>q</code>相乘。</p><p>那麼，我們可以把這個公式依照餘數定理轉換形式得到兩式：</p><blockquote><p>c^d mod p = m1 —(1)<br>c^d mod q = m2 —(2)</p></blockquote><p>其中，(1)式中的<code>m1</code>可以使用費馬小定理簡化運算，我們把<code>d = d mod (p-1)</code>帶入：</p><blockquote><p>c^(d mod (p-1))  mod p</p></blockquote><p>m2同理。</p><p>接着，我們令一常數爲<code>h</code>，(2)式可以改寫爲<code>c^d = m2 + hq</code>，代入第(1)式：</p><blockquote><p>(m2 + hq) mod p = m1<br>→ (m1 - m2) mod p = hq</p></blockquote><p>因爲<code>p</code>跟<code>q</code>互質，我們可以將兩邊同乘<code>q</code>的倒數<code>q^(-1)</code>得到：</p><blockquote><p>((m1 - m2 ) q^(-1))  mod p = h q q^(-1)<br>-&gt; h = ((m1 - m2 ) q^(-1))  mod p</p></blockquote><p>最後，我們知道<code>n=pq</code>，所以可以推得：</p><blockquote><p>m = c^d mod n = m2 + hq</p></blockquote><p>因爲這邊公式沒有用數學格式表示，可能比較難看，可以參考<span class="exturl" data-url="aHR0cDovL2ppYW5pYXUuYmxvZ3Nwb3QuY29tLzIwMTQvMDUvcnNhLWRlY3J5cHQtd2l0aC1jcnQuaHRtbA==">這邊<i class="fa fa-external-link-alt"></i></span>，會有比較好看的敘述。</p><p>程式上的實作可以參考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvd2Vhay1yc2EtZGVjcnlwdGlvbi1jaGluZXNlLXJlbWFpbmRlci10aGVvcmVtLw==">這邊<i class="fa fa-external-link-alt"></i></span>，以下是節錄並修改成python3版本的程式碼。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function to find the gcd of two </span></span><br><span class="line"><span class="comment"># integers using Euclidean algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="keyword">if</span> q == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">return</span> gcd(q, p % q)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function to find the</span></span><br><span class="line"><span class="comment"># lcm of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p * q / gcd(p, q)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function implementing extended</span></span><br><span class="line"><span class="comment"># euclidean algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">e, phi</span>):</span></span><br><span class="line">    <span class="keyword">if</span> e == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (phi, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g, y, x = egcd(phi % e, e)</span><br><span class="line">        <span class="keyword">return</span> (g, x - (phi // e) * y, y)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function to compute the modular inverse</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">e, phi</span>):</span></span><br><span class="line">    g, x, y = egcd(e, phi)</span><br><span class="line">    <span class="keyword">return</span> x % phi</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Implementation of the Chinese Remainder Theorem</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chineseremaindertheorem</span>(<span class="params">dq, dp, p, q, c</span>):</span></span><br><span class="line">    m1 = <span class="built_in">pow</span>(c, dp, p) <span class="comment"># Message part 1</span></span><br><span class="line">    m2 = <span class="built_in">pow</span>(c, dq, q) <span class="comment"># Message part 2</span></span><br><span class="line">    qinv = modinv(q, p)</span><br><span class="line">    h = (qinv * (m1 - m2)) % p</span><br><span class="line">    m = m2 + h * q</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Driver Code</span></span><br><span class="line">p = <span class="number">9817</span></span><br><span class="line">q = <span class="number">9907</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">36076319</span></span><br><span class="line">d = modinv(e, lcm(p - <span class="number">1</span>, q - <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">pow(a, b, c) calculates a raised to power b </span></span><br><span class="line"><span class="string">modulus c, at a much faster rate than pow(a, b) % c</span></span><br><span class="line"><span class="string">Furthermore, we use Chinese Remainder Theorem as it</span></span><br><span class="line"><span class="string">splits the equation such that we have to calculate two</span></span><br><span class="line"><span class="string">values whose equations have smaller moduli and exponent  </span></span><br><span class="line"><span class="string">value, thereby reducing computing time.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">dq = <span class="built_in">pow</span>(d, <span class="number">1</span>, q - <span class="number">1</span>)</span><br><span class="line">dp = <span class="built_in">pow</span>(d, <span class="number">1</span>, p - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(chineseremaindertheorem(dq, dp, p, q, c))</span><br></pre></td></tr></table></figure><h4 id="Encryption-Schemes"><a href="#Encryption-Schemes" class="headerlink" title="Encryption Schemes"></a>Encryption Schemes</h4><hr><p>這個部分來說明Sec.7的內容。</p><p>主要是對於加解密額外過程的解說，也就是加密前的『填充（padding）』部分。</p><p>那爲什麼要padding呢？</p><p>因爲我們知道明文長度不一定與金鑰長度相同，而且區塊加密的狀況，我們必須要將明文切成一塊塊來進行加密。</p><p>但是，就算切成一塊塊還是會有長度不夠的狀況，因此我們還是需要做padding。</p><p>而padding除了能夠增加混淆性外，剛好也能夠把我們是用公鑰還是私鑰加密的資訊包含進去。</p><h5 id="RSAES-PKCS1-V1-5"><a href="#RSAES-PKCS1-V1-5" class="headerlink" title="RSAES-PKCS1-V1_5"></a>RSAES-PKCS1-V1_5</h5><p>在PKCS1-v1_5中定義的加密流程如以下順序：</p><ol><li>原文經過EME-PKCS1-v1_5編碼產生EM（這邊就是所謂的padding了）</li><li>經過OS2IP函數把EM轉成正整數以進行RSA裏面的數學運算</li><li>經過RSAEP的數學運算加密EM</li><li>把剛剛加密的結果經由I2OSP轉成長度爲k的密文C</li></ol><p>很少人會跟你講PKCS#1講得重點是填充，大部分人都會說PKCS#1在說加解密。</p><p>其實也沒有錯，畢竟填充只是其中一個步驟。但個人認爲這才是精髓，因爲沒講誰會知道。</p><p>解密流程就是反過來做，如下：</p><ol><li>密文C經過OS2IP轉成正整數</li><li>把剛剛的正整數經由RSADP解密</li><li>上一步的結果經由I2OSP轉成長度爲k的EM</li><li>根據EME-PKCS1-v1_5解碼EM得到原文M</li></ol><h6 id="EME-PKCS1-v1-5-Encoding-amp-Decoding"><a href="#EME-PKCS1-v1-5-Encoding-amp-Decoding" class="headerlink" title="EME-PKCS1-v1_5 Encoding &amp; Decoding"></a>EME-PKCS1-v1_5 Encoding &amp; Decoding</h6><p>這邊是講解Padding的過程，也就是EME-PKCS1-v1_5如何編碼。</p><p>解碼就不提了，因爲按照步驟倒回來就可以了。</p><p>上面有說到編碼產生<code>EM</code>，那這個<code>EM</code>（Encoded Message）到底是怎麼組成的？</p><p>PKCS裏面是這樣寫的：</p><blockquote><p>EM = 00 || BT || PS || 00 || M</p></blockquote><p>裏面的<code>||</code>是分割符號，<code>BT</code>是資料塊的型別（Block Type），<code>PS</code>是填充用字串（Padding String），<code>M</code>是明文資料（Message）。</p><p>根據這個定義拼湊出EM，我們就可以得到一個具有PKCS承認合法的padding格式。</p><p>其中，BT跟PS的用途如以下：</p><ul><li><p>資料塊格式（BT）<br>  用來標示我加密使用的是公鑰還是私鑰。<br>  Private Key：00, 01（00容易混淆，不建議使用）<br>  Public Key：02</p></li><li><p>填充用字串（PS）<br>  用來把整個EM填充成同金鑰長度的資料塊。<br>  長度是金鑰長度-明文長度-前導00的1 octet-BT的1 octet-分割用00的1 octet，    也就是<code>金鑰長度-明文長度-3 octets</code>。</p><p>  如果BT是00，則PS全部填00。（明文開頭是00就完蛋，不建議使用）<br>  如果BT是01，則PS全部填FF。<br>  如果BT是02，則PS用非0的亂數填充。</p></li></ul><p>接下來又到了歡樂問答時間，這邊有三個問題。</p><ol><li><p>爲什麼要前導00？<br> 沒有爲什麼，定義說的就這樣。</p></li><li><p>爲什麼使用私鑰的時候，全部填FF？<br> 有一種說法是因爲安全性。因爲全填FF的話，可以讓值變很大以防止透過運算的方式攻擊。也可能還有其他原因要再想想。</p></li><li><p>亂數看起來比較安全，爲什麼不填充亂數就好？<br> 這邊可以想想看，我們公鑰加密才是填充亂數是爲什麼。主要是目的不同，因爲公鑰加密是爲了在充滿敵人的環境傳遞訊息，所以需要高度的混淆性。<br> 私鑰加密則是一種認可訊息的方式，別人只管驗證就好，也就不需要那麼麻煩。</p></li></ol><p>最後，我們直接看個以OpenSSL實作加密填充的例子。</p><p>這邊是以RSA-2048做例子。</p><ul><li>用私鑰加密前的填充</li></ul><p><img src="https://i.imgur.com/XBhWSgm.png" alt="private_key"></p><ul><li>用公鑰加密前的填充</li></ul><p><img src="https://i.imgur.com/SxnPfCz.png" alt="public_key"></p><h5 id="RSAES-OAEP"><a href="#RSAES-OAEP" class="headerlink" title="RSAES-OAEP"></a>RSAES-OAEP</h5><p>在RSAES-OAEP中定義的加密流程如以下順序：</p><ol><li>原文經過EME-OAEP編碼產生EM（這邊就是所謂的padding了）</li><li>經過OS2IP函數把EM轉成正整數以進行RSA裏面的數學運算</li><li>經過RSAEP的數學運算加密EM</li><li>把剛剛加密的結果經由I2OSP轉成長度爲k的密文C</li></ol><p>解密流程就是反過來做，如下：</p><ol><li>密文C經過OS2IP轉成正整數</li><li>把剛剛的正整數經由RSADP解密</li><li>上一步的結果經由I2OSP轉成長度爲k的EM</li><li>根據EME-OAEP解碼EM得到原文M</li></ol><p>基本上，步驟跟剛剛的v1_5一模一樣，只是編解碼的方法不一樣而已。</p><h6 id="EME-OAEP-Encoding-amp-Decoding"><a href="#EME-OAEP-Encoding-amp-Decoding" class="headerlink" title="EME-OAEP Encoding &amp; Decoding"></a>EME-OAEP Encoding &amp; Decoding</h6><p>基本上，OAEP的填充流程如下：</p><p><img src="https://i.imgur.com/6SV8Vit.png" alt="oaep-flow"></p><p>這個圖是參考PKCS內的流程跟<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhbXNobzIvYXJ0aWNsZS9kZXRhaWxzLzg0MjU1MTcz">這邊<i class="fa fa-external-link-alt"></i></span>畫的，但是光看圖可能還是會不太明白實際上是怎麼跑的。</p><p>這邊就以例子來演示填充的編碼流程，解碼則是按照步驟倒回來就行了。</p><p><img src="https://i.imgur.com/onAOFL3.png" alt="1"></p><p><img src="https://i.imgur.com/Ui4NmUh.png" alt="2"></p><p><img src="https://i.imgur.com/63qxp8P.png" alt="3"></p><p><img src="https://i.imgur.com/qs5M1Jj.png" alt="4"></p><p><img src="https://i.imgur.com/7zgvnbW.png" alt="5"></p><p><img src="https://i.imgur.com/O2349Yt.png" alt="6"></p><p><img src="https://i.imgur.com/FCFlPXi.png" alt="7"></p><p>這邊可能會有兩個問題。</p><ol><li><p><code>Label</code>是什麼？<br> Label通常是空字串（之前有說過空字串也可以雜湊），如果有需要使用的話必須再自行定義。PKCS#1的v2.2裏面有說如果用空字串以外的Label會out of scope。</p></li><li><p><code>MGF</code>是什麼？<br> 全名是Mask generation function。透過MGF，我們可以長度不等的資料用遮罩來罩住，讓它能夠產生一個固定長度的資料以便我們後面做XOR（長度必須相同才能做嘛）。通常是使用雜湊相關的函數如SHA-1後，再做截斷來達成。</p></li></ol><p>到這邊OAEP就結束了，這些也是一般我們做RSA的加解密會常用到的填充編碼。</p><p>那麼，簽驗章的部分也有在PKCS#1中有定義，這邊就不多做說明了。</p><p>詳細可以參考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NhbXNobzIvYXJ0aWNsZS9kZXRhaWxzLzg0MjU1Mzgy">這邊<i class="fa fa-external-link-alt"></i></span>，有更多的圖解，包含MGF也有流程說明。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><hr><p>這一次，我們提到的RSA實際上的加密並非單純數學運算。</p><p>畢竟只有數學運算的話，同樣的明文加密會變成同樣的密文，這樣不用數學，我們使用分析破解，不需要金鑰就可以進行攻擊了。</p><p>所以一開始說的RSA加密必須加料就是填充，而填充的方式就如同上面流程一樣複雜。</p><h2 id="圖片串"><a href="#圖片串" class="headerlink" title="圖片串"></a>圖片串</h2><hr><p>這次用到的圖片都放在Imgur的免空，<span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vYS80SXBHbGVZ">這裏<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><hr><p>原本沒想把padding的部分寫出來，後來想想還是整理一下好了。</p><p>這些資料或許可以幫助到一些想進入或剛進入這個領域的人。</p><p>真希望當初學習的時候也有這樣的資料可以看 😥</p><p>這種類型的知識討厭的地方除了知道就知道，不知道就真的不知道外，還需要各種通靈當初爲什麼這樣設計，很高機率演變成先射箭再畫靶去解釋原因。</p><p>不過通靈失敗率也很高就是了，畢竟跟程式一樣，文件不完善外，又不是最初的開發者，怎麼可能知道在寫什麼？😥</p><p>如果要轉載，再麻煩標註作者跟網址，謝謝！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;這篇算是之前資安常識裏面提到RSA加密的延伸補充。&lt;/p&gt;
&lt;p&gt;我們說的RSA加密不是單純只有加密，還必須加料。&lt;/p&gt;
&lt;p&gt;這樣才能夠有一定的混淆性。&lt;/p&gt;
&lt;p&gt;這邊記錄一下PKCS#1裏面定義的RSA加解密流程。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="cryptograph" scheme="http://natlee.github.io/Blog/tags/cryptograph/"/>
    
    <category term="security" scheme="http://natlee.github.io/Blog/tags/security/"/>
    
    <category term="encoding" scheme="http://natlee.github.io/Blog/tags/encoding/"/>
    
    <category term="decoding" scheme="http://natlee.github.io/Blog/tags/decoding/"/>
    
    <category term="RSA" scheme="http://natlee.github.io/Blog/tags/RSA/"/>
    
    <category term="PKCS" scheme="http://natlee.github.io/Blog/tags/PKCS/"/>
    
  </entry>
  
  <entry>
    <title>資安常識(3) - 簽驗章流程與完整憑證解析</title>
    <link href="http://natlee.github.io/Blog/posts/736906820/"/>
    <id>http://natlee.github.io/Blog/posts/736906820/</id>
    <published>2021-10-05T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>上次提到的加密演算法『公鑰加密，私鑰解密』達成了PKI中傳遞資料的隱密性，以及雜湊演算法的低碰撞性可以檢查傳遞資料的完整性。</p><p>那麼，身份鑑別跟不可否認性呢？我們來看看『私鑰加密，公鑰解密』，簽驗章流程與憑證是什麼。</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><h3 id="數位簽章"><a href="#數位簽章" class="headerlink" title="數位簽章"></a>數位簽章</h3><hr><h4 id="何謂數位簽章"><a href="#何謂數位簽章" class="headerlink" title="何謂數位簽章"></a>何謂數位簽章</h4><hr><p>什麼是數位簽章(digital signature)？</p><p>我們還是先來看看<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNiU5NSVCOCVFNCVCRCU4RCVFNyVCMCVCRCVFNyVBQiVBMA==">維基百科<i class="fa fa-external-link-alt"></i></span>的說法：</p><blockquote><p>數位簽章（Digital Signature），又稱公鑰數位簽章，是一種功能類似寫在紙上的普通簽名、但是使用了公鑰加密領域的技術，以用於鑑別數位訊息的方法。一套數位簽章通常會定義兩種互補的運算，一個用於簽名，另一個用於驗證。法律用語中的電子簽章與數位簽章代表之意義並不相同。電子簽章指的是依附於電子文件並與其相關連，用以辨識及確認電子文件簽署人身分、資格及電子文件真偽者；數位簽章則是以數學演算法或其他方式運算對其加密而形成的電子簽章。意即並非所有的電子簽章都是數位簽章。</p></blockquote><p>維基百科的解釋落落長，我們根據上面的敘述拆出三個關鍵字來分別定義：</p><ol><li><p>普通簽名<br> 一般我們在現實生活中，常常需要簽署文件表示同意或是認可，這就是普通簽名。</p></li><li><p>電子簽章<br> 也叫做電子簽名，但在網路世界中，我們沒辦法拿筆進行簽名，所以我們必須要依附電子文件的方式來進行簽署。在我們不能違背不可否認性的狀況下，就需要有第三方平臺來確保雙方電子簽名的公正性，如有一些提供這項服務的平臺，像是Adobe Sign、DocuSign等等。</p></li><li><p>數位簽章<br> 跟電子簽章類似，在網路世界裡，我們需要證明自己身份的話，可以遵循公開金鑰系統來建立一對公私鑰，私鑰自行保管，公鑰盡量散佈。那麼，我們使用私鑰來對資料加密，別人可以用我們散佈的公鑰解密。這樣即可證明這資料是我認可的，也可以證明是由我發出的，以此達到確認身份，也就是身份鑑別的效果。</p></li></ol><p>其實，光看這些名字跟解釋很容易被誤導以爲是同個東西，但並不盡然，它們差一個字就差千萬里。</p><p>然而，全世界有使用電子簽章或數位簽章的地方都有以政府機關爲首去定義這些名詞。</p><p>在台灣也有個法條，叫做<span class="exturl" data-url="aHR0cHM6Ly9sYXcubW9qLmdvdi50dy9MYXdDbGFzcy9MYXdBbGwuYXNweD9QQ29kZT1KMDA4MDAzNw==">電子簽章法<i class="fa fa-external-link-alt"></i></span>，裏面定義的這些名詞，都是不同的東西。</p><p>我們以下所有的數位簽章都以簽章爲代稱。</p><p>我們知道什麼是簽章之後，接下來我們來看看簽章跟驗章的流程是怎麼跑的。</p><h4 id="簽驗章流程"><a href="#簽驗章流程" class="headerlink" title="簽驗章流程"></a>簽驗章流程</h4><hr><p>我們在瞭解簽驗章流程的時候，一定要知道我們爲何而做。</p><p>就是爲了知道對方身份以及判斷拿到的資料是否爲對方所認可的。</p><p>那麼，我們有請兩位常常出現在各大資安課本的角色 Alice 跟 Bob 出場表演。</p><h5 id="簽章"><a href="#簽章" class="headerlink" title="簽章"></a>簽章</h5><p><img src="https://i.imgur.com/0NJQNkq.png" alt="簽章"></p><p>圖片中的順序我再用文字詳細打一次。</p><ol><li>Alice對文件產生雜湊，這個文件其實就是資料。</li><li>Alice用Alice的<strong>私鑰</strong>對文件的雜湊值，也就是對摘要進行加密，產生Alice的簽名。</li><li>Alice將文件跟簽名傳送給Bob。</li></ol><p>從這邊我們可以看出Alice的私鑰可以用Alice的公鑰去解密，也就是我們可以知道是Alice去簽署了這個資料。</p><p>那這邊有個問題是爲什麼我們的不是拿私鑰直接對資料加密，而是對資料產生的雜湊值加密？</p><p>仔細想想，爲什麼我們不這樣做，除了保障文件完整，我們還直接少了一個步驟，這樣不很好嗎？</p><p>這是因爲我們的文件有可能很大，非對稱加密的時間會遠超過我們預期，也就是越大的文件，我們需要加密越久。</p><p>相對的，我們對固定長度的雜湊值進行加密，這樣的做法來得比較有效率。</p><p>關於這個問題，這邊也有個答案可以參考看看，<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTcxOTc0L3doeS1pcy1oYXNoaW5nLWRpZ2VzdC1lbXBsb3llZC1pbi1kaWdpdGFsLXNpZ25hdHVyZXM=">Why is hashing (digest) employed in digital signatures?<i class="fa fa-external-link-alt"></i></span>。</p><p>那麼，另外一個問題是萬一我的文件，也就是資料很小，小到比金鑰還短，甚至比雜湊值<br>短，這樣加密不就比起對雜湊值加密來得更有效率嗎？</p><p>就算資料比金鑰還短，我們在非對稱加密有說過，一樣得padding到金鑰長度才能加密。所以以RSA-1024來說也不可能比雜湊值短。</p><p>那如果我們使用能夠產生較短金鑰長度的加密算法ECC家族的ECDSA-224來說的話，這樣或許有可能資料長度比雜湊SHA-256來得短。但這種狀況多嗎？其實並不多。</p><p>但談論這些並沒有太大的意義，因爲我們一開始所說的RFC裏面就已經定義了數位簽章。</p><p>可以參照<span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyMzE1">PKCS#7<i class="fa fa-external-link-alt"></i></span>，裏面有定義簽章是對message的digest加密。</p><h5 id="驗章"><a href="#驗章" class="headerlink" title="驗章"></a>驗章</h5><p><img src="https://i.imgur.com/L6pD9F2.png" alt="驗章"></p><ol start="4"><li>Bob用Alice散佈在外的公鑰對簽名進行解密。</li><li>Bob對文件生成雜湊值。<br> 這邊會有疑問的是，要如何知道是哪一種雜湊？<br> 答案請參照<span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyMzE1">PKCS#7<i class="fa fa-external-link-alt"></i></span>，裏面有定義簽章的雜湊類型跟更詳細的傳送流程。</li><li>比對解密後跟自己生成的雜湊值是否一致，以此確認文件是否完整。<br> 然後Bob能使用Alice的公鑰解密成功，其實也代表簽名是Alice的。<br> 其中，任何一項出錯都會導致驗章失敗。</li></ol><p>剛剛有一個問題是，爲什麼我們不對文件加密，這邊也可以看出來最後我們比對的是雜湊值，如果我們文件很大的話，比對大文件耗的時間肯定比固定長度的雜湊值來得多。</p><h3 id="憑證"><a href="#憑證" class="headerlink" title="憑證"></a>憑證</h3><hr><h4 id="何謂憑證"><a href="#何謂憑證" class="headerlink" title="何謂憑證"></a>何謂憑證</h4><hr><p>剛剛提到簽章就是用自己的私鑰去對文件的雜湊進行簽署（加密），可是問題來了！</p><p>大家都可以隨意產生公私鑰對，用OpenSSL就可以做，我不就可以亂產生公鑰散佈到網路上宣稱我是別人。</p><p>這樣的話，我們要怎麼知道這個簽章到底是不是你簽出來的？</p><p>這邊就該是憑證登場的時候了，也就是我們需要第三方來證明這個公鑰到底能不能夠被信任，這樣才能達成我們一開始說到的『私鑰加密，公鑰解密』。那麼，這個第三方就是PKI內的角色CA。</p><p>我們在PKI那邊有提到憑證申請的時候，CA會打開你的CSR（申請資料及公鑰），然後抽出裏面的資料用CA自己的私鑰對它加密以證明你的身份及這份公鑰是由我這個CA擔保的。</p><p>這邊又有一個疑問，我用OpenSSL也可以自己當CA啊！那不就可以自己隨便幫別人簽憑證了嗎？</p><p>沒錯！你是可以隨便幫別人簽，但你簽的憑證能夠被信任嗎？</p><p>但這個問題就跟這些問題是一樣的。</p><blockquote><p>爲什麼無照駕駛會被罰錢<br>爲什麼學生證能證明你是學生<br>爲什麼畢業證書<br>…</p></blockquote><p>這些證明的背後，都有一個具有公信力的角色存在，所以他們頒發的證明、證書都能夠被信任。那麼，我們自己亂簽的憑證是不具有公信力的。</p><p>接下來，我們來看看剛剛所說的一張憑證的訊息通常有哪些欄位並且它是用什麼方式表示的。</p><h4 id="X-509-憑證格式"><a href="#X-509-憑證格式" class="headerlink" title="X.509 憑證格式"></a>X.509 憑證格式</h4><hr><p>有關憑證格式的規範寫在<span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM1Mjgw">RFC 5280<i class="fa fa-external-link-alt"></i></span>。</p><p>我們先拿一張實際的憑證來看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is a real-world X.509 certificate, specifically a root CA.</span><br><span class="line">https://letsencrypt.org/certificates/</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0NlowSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMTGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EFq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8SMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0Z8h/pZq4UmEUEz9l6YKHy9v6Dlb2honzhT+Xhq+w3Brvaw2VFn3EK6BlspkENnWAa6xK8xuQSXgvopZPKiAlKQTGdMDQMc2PMTiVFrqoM7hD8bEfwzB/onkxEz0tNvjj/PIzark5McWvxI0NHWQWM6r6hCm21AvA2H3DkwIDAQABo4IBfTCCAXkwEgYDVR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAYYwfwYIKwYBBQUHAQEEczBxMDIGCCsGAQUFBzABhiZodHRwOi8vaXNyZy50cnVzdGlkLm9jc3AuaWRlbnRydXN0LmNvbTA7BggrBgEFBQcwAoYvaHR0cDovL2FwcHMuaWRlbnRydXN0LmNvbS9yb290cy9kc3Ryb290Y2F4My5wN2MwHwYDVR0jBBgwFoAUxKexpHsscfrb4UuQdf/EFWCFiRAwVAYDVR0gBE0wSzAIBgZngQwBAgEwPwYLKwYBBAGC3xMBAQEwMDAuBggrBgEFBQcCARYiaHR0cDovL2Nwcy5yb290LXgxLmxldHNlbmNyeXB0Lm9yZzA8BgNVHR8ENTAzMDGgL6AthitodHRwOi8vY3JsLmlkZW50cnVzdC5jb20vRFNUUk9PVENBWDNDUkwuY3JsMB0GA1UdDgQWBBSoSmpjBH3duubRObemRWXv86jsoTANBgkqhkiG9w0BAQsFAAOCAQEA3TPXEfNjWDjdGBX7CVW+dla5cEilaUcne8IkCJLxWh9KEik3JHRRHGJouM2VcGfl96S8TihRzZvoroed6ti6WqEBmtzw3Wodatg+VyOeph4EYpr/1wXKtx8/wApIvJSwtmVi4MFU5aMqrSDE6ea73Mj2tcMyo5jMd6jmeWUHK8so/joWUoHOUgwuX4Po1QYz+3dszkDqMp4fklxBwXRsW10KXzPMTZ+sOPAveyxindmjkW8lGy+QsRlGPfZ+G6Z6h7mjem0Y+iWlkYcV4PIWL1iwBi8saCbGS5jN2p8M+X+Q7UNKEkROb3N6KOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>一開始看到應該會覺得這三小，怎麼一堆亂碼。</p><p>其實仔細看它是有格式的，我們可以注意到上面有些地方我們還是看得懂的。</p><p>像是<code>-----BEGIN CERTIFICATE-----</code>跟<code>-----END CERTIFICATE-----</code>。</p><p>這個是一種叫做PEM的格式。</p><h5 id="PEM-格式"><a href="#PEM-格式" class="headerlink" title="PEM 格式"></a>PEM 格式</h5><hr><p>PEM全名是Privacy Enhanced Mail，這種格式滿好理解的。</p><p>就是一個<code>BEGIN</code>，然後夾東西，最後放個<code>END</code>。</p><p>就像上面的憑證一樣，根據維基百科，關於PEM格式的定義在RFC 1421 - 1424。</p><blockquote><p>The PEM format was first developed in the privacy-enhanced mail series of <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVxdWVzdF9mb3JfQ29tbWVudHM=">RFCs<i class="fa fa-external-link-alt"></i></span>: RFC 1421, RFC 1422, RFC 1423, and RFC 1424.</p></blockquote><p>當初會有這個格式是因爲如其名，隱私強化郵件，也就是把內容亂碼化，讓別人沒辦法直接懂，需要經過一次解碼才能看懂，但又需要分隔符號來告知說亂碼化的區塊是什麼，這個格式就因此誕生。</p><p>那麼，這個亂碼化也只是做一次base64的編碼，所以裏面的那陀東西就是用Base64進行編碼的產生的。</p><h5 id="Base64-編解碼"><a href="#Base64-編解碼" class="headerlink" title="Base64 編解碼"></a>Base64 編解碼</h5><hr><p>我們常常聽到Base64，它就是由英文字母<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>和 <code>/</code>, <code>+</code> 共64種在ASCII內可正常顯示的字元來進行編碼（所以裏面的bit代表的也是ASCII上實際對應的編碼），最後再加上<code>=</code>用來填充，然後編碼的結果是字串。</p><p>那這邊可能有問題是說，爲什麼需要填充？</p><p>首先，我們先看看它的原理。</p><p>Base64是每6個bit爲一單位進行編碼。</p><p><img src="https://i.imgur.com/mVnHAZO.png" alt="sample"></p><p>可是一個byte是8個bit，所以如果沒辦法被8整除的話，就必須做填充，那麼填充就是添加<code>=</code>來達成。</p><p><img src="https://i.imgur.com/tbQyKiA.png" alt="equal_sample"></p><p>看到這邊可能會產生一些問題。</p><p>像是這樣換算下來，它不是讓資料變得更長了嗎？不會很不方便嗎？</p><p>還有科技不是一直在進步，爲什麼現在還在用base64？</p><p>先回答第一個問題，這個格式本身的目的就是爲了以前郵件傳輸附件，而附件本身又是binary，沒辦法直接傳送，所以才挑選ASCII上的常用可視字元來做轉換。</p><p>它當然把資料變更長了，但也因此能夠傳送了，這就是所謂的有得必有失。</p><p>回答第二個問題之前，我們首先要知道ASCII其實以前是用7個bit去做編碼，現在會多一位是爲了檢查。</p><p>我們可以參考<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmJjLmNvLnVrL2JpdGVzaXplL2d1aWRlcy96c25icjgyL3JldmlzaW9uLzU=">BBC的定義<i class="fa fa-external-link-alt"></i></span>：</p><blockquote><p>ASCII uses <strong>8 bits</strong> to represent a character.<br>However, one of the bits is a <strong>parity bit</strong>. This is used to perform a parity check (a form of error checking). This uses up one bit, so ASCII represents 128 characters (the equivalent of 7 bits) with 8 bits rather than 256.</p></blockquote><p>那麼，以前大多數的系統是以8個bit爲一單位，所以會在傳送的時候有機會被擦除多餘的bit，因而導致訊息傳遞有誤。</p><p>所以，Base64的做法才誕生，這樣我們就可以對任意數量的bit進行編碼。</p><p>也因此，我們現在仰賴base64來進行安全的傳送文本資料。</p><p>於是我們傳遞文本會有以下步驟：</p><ol><li>文本資料先經過 UTF-8 編碼或其他編碼成bytes</li><li>bytes的資料再經過base64的安全轉換成base64編碼的文本資料</li><li>base64編碼的文本資料再轉換成ASCII編碼的bytes資料進行傳送</li></ol><p>那麼，接收方只要反向操作，就能夠把接收到的bytes資料轉回最一開始的文本資料了。</p><p>從這個方法來看，我們其實除了郵件的附件外，任何binary資料都可以使用base64編碼再安全的轉成ASCII的bytes進行傳送，像是圖片也可以。</p><p>這也就是爲什麼現在還在用base64的原因。</p><p>更詳細的答案可以參考<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzUzODAyMS93aHktZG8td2UtdXNlLWJhc2U2NA==">這邊<i class="fa fa-external-link-alt"></i></span>。</p><ul><li>Base64 URL</li></ul><p>另外，base64有一個派生叫base64 URL，它們只差在兩個不同的字在轉換上不一樣。</p><p><img src="https://i.imgur.com/IiGJnLK.png" alt="base64_url_compare"></p><p>這兩個被替代的符號分別是：</p><ul><li><p>+ -&gt; -<br>  這是因爲網站對路徑解析的時候，加號會被當成參數，所以得換掉。</p></li><li><p>/ -&gt; _<br>  這是因爲網站解析斜線會被當成子路徑，所以也得換掉。</p></li></ul><p>那麼，這個編碼方式通常被用來網路服務直接存取base64 URL文字再解碼成binary的做法。</p><p>在base64這邊最後，有個問題，就是爲什麼一定要64？</p><p>這沒什麼好說的，就單純因爲它們當初就定義這64個字元。</p><p>其實還有其他版本的編碼，像是base56，這個編碼就把一些容易混淆的字元換掉，像是<code>0</code>跟大寫的英文字母<code>o</code>，或是<code>1</code>跟大寫的英文字母<code>i</code>等等。</p><p>整個base56的集合就只剩以下這些字元：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz</span><br></pre></td></tr></table></figure><p>接着，我們把憑證這串base64解碼之後，會得到什麼？</p><h5 id="DER-編碼"><a href="#DER-編碼" class="headerlink" title="DER 編碼"></a>DER 編碼</h5><hr><p>我們使用base64解碼還原後，會得到以下這樣的binary資料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 82 04 92 30 82 03 7A A0 03 02 01 02 02 10 0A 01 41 42 00 00 01 53 85 73 6A 0B 85 EC A7 08 30 0D 06 09 2A 86 48 86 F7 0D 01 01 0B 05 00 30 3F 31 24 30 22 06 03 55 04 0A 13 1B 44 69 67 69 74 61 6C 20 53 69 67 6E 61 74 75 72 65 20 54 72 75 73 74 20 43 6F 2E 31 17 30 15 06 03 55 04 03 13 0E 44 53 54 20 52 6F 6F 74 20 43 41 20 58 33 30 1E 17 0D 31 36 30 33 31 37 31 36 34 30 34 36 5A 17 0D 32 31 30 33 31 37 31 36 34 30 34 36 5A 30 4A 31 0B 30 09 06 03 55 04 06 13 02 55 53 31 16 30 14 06 03 55 04 0A 13 0D 4C 65 74 27 73 20 45 6E 63 72 79 70 74 31 23 30 21 06 03 55 04 03 13 1A 4C 65 74 27 73 20 45 6E 63 72 79 70 74 20 41 75 74 68 6F 72 69 74 79 20 58 33 30 82 01 22 30 0D 06 09 2A 86 48 86 F7 0D 01 01 01 05 00 03 82 01 0F 00 30 82 01 0A 02 82 01 01 00 9C D3 0C F0 5A E5 2E 47 B7 72 5D 37 83 B3 68 63 30 EA D7 35 26 19 25 E1 BD BE 35 F1 70 92 2F B7 B8 4B 41 05 AB A9 9E 35 08 58 EC B1 2A C4 68 87 0B A3 E3 75 E4 E6 F3 A7 62 71 BA 79 81 60 1F D7 91 9A 9F F3 … skipping 160 bytes … FC F2 33 6A B9 39 31 C5 AF C4 8D 0D 1D 64 16 33 AA FA 84 29 B6 D4 0B C0 D8 7D C3 93 02 03 01 00 01 A3 82 01 7D 30 82 01 79 30 12 06 03 55 1D 13 01 01 FF 04 08 30 06 01 01 FF 02 01 00 30 0E 06 03 55 1D 0F 01 01 FF 04 04 03 02 01 86 30 7F 06 08 2B 06 01 05 05 07 01 01 04 73 30 71 30 32 06 08 2B 06 01 05 05 07 30 01 86 26 68 74 74 70 3A 2F 2F 69 73 72 67 2E 74 72 75 73 74 69 64 2E 6F 63 73 70 2E 69 64 65 6E 74 72 75 73 74 2E 63 6F 6D 30 3B 06 08 2B 06 01 05 05 07 30 02 86 2F 68 74 74 70 3A 2F 2F 61 70 70 73 2E 69 64 65 6E 74 72 75 73 74 2E 63 6F 6D 2F 72 6F 6F 74 73 2F 64 73 74 72 6F 6F 74 63 61 78 33 2E 70 37 63 30 1F 06 03 55 1D 23 04 18 30 16 80 14 C4 A7 B1 A4 7B 2C 71 FA DB E1 4B 90 75 FF C4 15 60 85 89 10 30 54 06 03 55 1D 20 04 4D 30 4B 30 08 06 06 67 81 0C 01 02 01 30 3F 06 0B 2B 06 01 04 01 82 DF 13 01 01 01 30 30 30 2E 06 08 2B 06 01 05 05 07 02 01 16 22 68 74 74 70 3A 2F 2F 63 70 73 2E 72 6F 6F 74 2D 78 31 2E 6C 65 74 73 65 6E 63 72 79 70 74 2E 6F 72 67 30 3C 06 03 55 1D 1F 04 35 30 33 30 31 A0 2F A0 2D 86 2B 68 74 74 70 3A 2F 2F 63 72 6C 2E 69 64 65 6E 74 72 75 73 74 2E 63 6F 6D 2F 44 53 54 52 4F 4F 54 43 41 58 33 43 52 4C 2E 63 72 6C 30 1D 06 03 55 1D 0E 04 16 04 14 A8 4A 6A 63 04 7D DD BA E6 D1 39 B7 A6 45 65 EF F3 A8 EC A1 30 0D 06 09 2A 86 48 86 F7 0D 01 01 0B 05 00 03 82 01 01 00 DD 33 D7 11 F3 63 58 38 DD 18 15 FB 09 55 BE 76 56 B9 70 48 A5 69 47 27 7B C2 24 08 92 F1 5A 1F 4A 12 29 37 24 74 51 1C 62 68 B8 CD 95 70 67 E5 F7 A4 BC 4E 28 51 CD 9B E8 AE 87 9D EA D8 BA 5A A1 01 9A DC F0 DD 6A 1D 6A D8 … skipping 160 bytes … 28 EA A4 AA 6E 7B 4C 7D 87 DD E0 C9 02 44 A7 87 AF C3 34 5B B4 42</span><br></pre></td></tr></table></figure><p>好了，所以我說這又是三小？</p><p>一坨十六進位的數字，根本看不懂！</p><p>其實它是依循一種叫做DER的編碼格式來排列這些數字。</p><p>DER全名是Distinguished Encoding Rule，中文就是『可識別編碼規則』。</p><p>而DER又是BER的一種被閹割格式。</p><p>等等我們會討論DER跟BER的差異。</p><p>我們先看看BER是什麼，BER全名是Basic Encoding Rule。</p><p>它是一種T-L-V格式。</p><p>等等！T-L-V又是什麼新名詞？</p><p>其實就是Type(或是Tag)-Length-Value的簡稱，也就是說如下圖範例：</p><p><img src="https://i.imgur.com/S4cwjR3.png" alt="T-L-V_format"></p><ul><li><p>Type<br>  用來表示後面資料的屬性。</p></li><li><p>Length<br>  用來表示後面資料的總長度，也就是後面有幾個byte資料（一個hex資料是4 bits，一個byte是8 bits，所以是兩個hex值）。</p></li><li><p>Value<br>  用來表示後面資料的RAW值。</p></li></ul><p>也就是說，我們有這三樣東西就可以完美的表示一個結構化的資料。</p><h6 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h6><hr><p>接下來，就要看看Type有哪些。</p><p>根據<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWC42OTAjVHlwZXM=">維基百科<i class="fa fa-external-link-alt"></i></span>上面列的表格：</p><p><img src="https://i.imgur.com/uNle3pT.png" alt="types"></p><p>最左邊的<code>Name</code>是指這個type / tag / label / class的名稱（超多種代稱）。</p><p>再來，<code>Permitted Construction</code>是指說這個class必須是哪種類型，是permitive？還是constructed？或是我全都要。</p><p>這邊會有疑問的是permitive到底是什麼？</p><p><img src="https://i.imgur.com/EzHgkFf.png" alt="permitive"></p><p>還是看不懂，爲什麼扯個類別可以提到原始？</p><p>那我們看看它相對的是constructed，也就是結構。</p><p>從這邊我們可以推論出來，這邊代表的是這個類別能放的東西是<strong>純粹的值</strong>還是可以放<strong>子結構資料</strong>。換句話說，就是陣列裏面能不能有陣列的意思。</p><p>最後，Tag number是這個類別的代表編號。</p><p>我們比較表格上面的decimal跟hex，可以發現初號機是<code>EOC</code>，它是編號<code>0x00</code>。</p><p>但其實，這編號是有意義的，可以參考<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWC42OTAjRW5jb2Rpbmc=">維基百科<i class="fa fa-external-link-alt"></i></span>裏面的定義。</p><p>裏面有提到這個表格：</p><p><img src="https://i.imgur.com/wmYATQs.png" alt="tag_define"></p><p>剛剛我們提到編號，接下來有更細節的編碼。</p><p>這邊舉例一個tag就是<code>0x30</code>的<code>sequence</code>，以二進位表示就是<code>0011 0000</code>。</p><p>以表格的模式拆解，會得到Octet1，變成<code>00 1 10000</code>。</p><p>從這邊可以看對上一個表格中，sequence的decimal表示是<code>16</code>，也就是二進位的<code>10000</code>。</p><p>那麼，它是的P/C是Primitive，也就是<code>1</code>，所以我們可以得到<code>110000</code>。</p><p>可是前綴還有<code>00</code>，這要怎麼解釋？</p><p>維基上面還有另外兩個表格，如下：</p><p><img src="https://i.imgur.com/Gdm97rH.png" alt="class_name"></p><p>這邊第一個表格定義了我們Tag Class，也就是Tag的類型，有點饒舌，但就是Tag本身還有被分類的意思。</p><p>那麼<code>0</code>就是所謂的ASN.1原生類別，寫成16進位就是<code>0x00</code>。</p><p>ASN.1我們等等會提到。</p><p>第二個表格則是再解釋了一次P/C的意思。</p><p>這樣線索都找齊了，我們可以拼出<code>sequence</code>的真正編碼<code>00 1 10000</code>。</p><p>可是剛剛說到的Octet 1後面還有一個Octet 2 onwards是什麼意思？</p><p>這時就要提到有一個東西叫Long form，也就是萬一我們與時俱進，多了很多tag，導致編號超過5個bit長度的時候，就會用到了。</p><p>那麼，我們今天編號真的超過的話，Tag Number就會全是1，也就是Octet 1的1-5位bit全都是1。</p><p>然後Octet 2的位子8就是1，後面1-7位就是實際編號，這邊要注意的是這1-7位編號不能全是0，也就是一定要有東西的意思。</p><p>也因爲Octet 2的關係，這樣我們能表示的編號就從Short form五位（最多只能到編號31）擴充到Long form七位（最多可以編號到 127）了。</p><h6 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h6><hr><p>剛剛說完Tag是什麼，我們來要看看Length。</p><p>根據維基百科提到這個表格：</p><p><img src="https://i.imgur.com/NBJmjNV.png" alt="length_form"></p><p>我們由一開始的範例可以看到一般長度也是由兩個hex值表示，但其實是1+7個bit表示。</p><p>按表格，第一位也就是編號8的位子跟剛剛tag欄位一樣是表示Long form還是short form，其他1-7位是表示實際長度。</p><p>那麼，如果編號8是0，後面的數字代表的就是short form的長度，7個bit最多可以表示到<code>0000000-1111111</code>，也就是<code>0-127</code>。例如<code>0x05</code>就是後面資料有五個byte的長度。</p><p>如果編號8是1，後面1-7位都是0的話，就代表長度是不定的。</p><p>那如果編號8的位置是1，那就有三種可能。</p><ol><li><p>Bits位置1-7全部都是0，那就是我的資料是不定長度，在最後資料結尾會有<code>00 00</code>來做分隔符號。<br> 例如：<code>30 80 02 01 05 00 00</code>，這串資料就是一個sequence的結構資料，裏面有一個不定長度的子結構，那這個子結構的type是<code>0x02</code>，我們查表可以看到是<code>Integer</code>，然後這個長度是<code>0x01</code>，也就是一個byte，資料爲<code>0x05</code>，結尾補上分隔符號<code>0x0000</code>。</p></li><li><p>Bits位置1-7如果是<code>0000001</code>-<code>1111110</code>，也就是decimal的<code>1-126</code>的話，就代表後面會有一個有限長度的資料，但長度太長，我沒辦法用一個bytes表示，所以跟剛剛的tag class一樣需要擴充，這個表示方式也稱爲Long form。<br> 這邊維基百科有個例子。<br> <img src="https://i.imgur.com/dTJmCc7.png" alt="long_form_example"></p><p> Octet 1是length，它的長度是<code>1 0000010</code>，最前面的<code>1</code>代表它是long form，長度需要用七個7bits來表示，寫成16進位，也就是<code>0x82</code>。那麼，後面七個bit是<code>0000010</code>，代表著它後面必定有兩個bytes來表示它的長度。<br> Octet 2跟Octet 3就是真正的資料長度<code>00000001 10110011</code>，用decimal表示就是<code>435</code>，也就是說後面必定接<strong>435個byte</strong>長度的資料。</p><p> 這邊有個問題是說，萬一資料長度還是超過<code>126</code>要怎麼辦？<br> 剛剛有說到不定長度的做法，就是<code>0x80</code>，然後後面接<code>0x0000</code>。</p><p> 不過，也可以想想看，如果我長度是最大值的126的話，代表我可以用126個byte表示資料長度，那麼126 bytes最多可以表示2^126-1個byte，也就代表我後面接的資料有2^126-1個byte這麼大。我們用計算機算一下，可以得到這個數字。</p><p> <img src="https://i.imgur.com/LcBVNpQ.png" alt="2^126-1"></p><p> 後面的除以1024^3是爲了把byte換算成TB，也就是說我們換算成TB還有10^28這麼多，以目前看來一般資料是不太可能超越這個數字。</p></li><li><p>Bits位置1-7是<code>1111111</code>的話，整個來看是<code>1111 1111</code>，目前是一個保留的位子。</p></li></ol><h6 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h6><hr><p>根據剛剛的Tag，我們知道這value是什麼類別，再根據Length知道這value的長度有多長。</p><p>那麼，value本身就有可能是各種類型的資料（反正都是binary），當然也有可能是一個新的結構，但這個結構也必須要遵從T-L-V格式去建立。</p><p>到這邊，還記得我們一開始的那個範例嗎？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 13 02 01 05 16 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f</span><br></pre></td></tr></table></figure><p>查表我們可以知道<code>0x02</code>是Integer，<code>0x16</code>是IA5String，也就是一種String。</p><p>我們就可以解析一下這個範例得到這樣的架構。</p><p><img src="https://i.imgur.com/3mhc3Hk.png" alt="sample"></p><p>其中，IA5String Tag後面的value我們可以根據ASCII解碼得到一個字串<code>Anybody there?</code>。</p><p>我們看完BER的T-L-V格式了，還記得我們這邊的標題其實是DER嗎？</p><h6 id="BER與DER的差異"><a href="#BER與DER的差異" class="headerlink" title="BER與DER的差異"></a>BER與DER的差異</h6><hr><p>剛剛有提到DER是閹割版的BER，那麼DER到底是什麼？</p><p>它跟BER相比有四個顯著的特性，分別是：</p><ol><li>長度一定要寫出來，而且越短越好。也就是說，它不能是<code>0x80</code>的不定長度。</li><li>Bitstring, octetstring跟其他受限的character strings，必須要是Primitive。</li><li>如果它的Type是<code>SET</code>的話，內容必須按照它的Type編號進行排序。</li><li>DER大多用在密碼學相關應用（像是這邊說的憑證）上，所以必須能夠被唯一表示。對於BER的Boolean來說，True的表示就是除了<code>0x00</code>外的<code>0x01-0xFF</code>。但這在DER不被允許，反而True只能是<code>0xFF</code>。</li></ol><p>所以有些人會說DER是BER的一種子集，這樣說其實也沒錯，它們的差異就如同上面所說。</p><p>這邊會有個問題是，BER既然可以解DER編碼，那爲什麼要特別再搞出一個DER？</p><p>我在上面其實也有提到了，DER大多是用在密碼學相關應用，因此才把BER閹割去定義一個更嚴格的格式。而且，談到安全的東西總不能馬虎，固定長度也是一個很重要的特性，總不可能我跟你說我要傳金鑰給你，然後不給你長度吧！</p><p>這一節的最後，總會有一種問題，就是這些原理啥的我都知道了，可是爲什麼要用DER？</p><p>有一個答案是因爲RFC裏面定義憑證必須使用DER編碼。</p><p>這樣可能會再衍生一個新的問題，那DER是怎麼來的？</p><p>我們就可以想想看另外一個問題，以前人怎麼傳資料的？</p><p>以前電腦通訊沒這麼發達，如果我在傳資料給你的時候，先跟你說我要傳什麼類型的資料，然後我資料有多長，這樣你收資料的時候就可以知道什麼時候才能把整個資料收完。</p><p>這不就是T-L-V格式的做法嗎？</p><p>也就是因爲通訊的需要，經過各種規範，最後迭代出BER這種做法，那DER只是嚴謹一點的BER。</p><h5 id="ASN-1"><a href="#ASN-1" class="headerlink" title="ASN.1"></a>ASN.1</h5><hr><p>我們在上面討論過DER編碼，也用了範例來瞭解。</p><p>那麼，舊圖重用。</p><p><img src="https://i.imgur.com/3mhc3Hk.png" alt="sample"></p><p>我可以直接跟你說，這就是ASN.1。</p><p>我們可以看看<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3L0FTTi4x">維基百科<i class="fa fa-external-link-alt"></i></span>怎麼說明ASN.1：</p><blockquote><p>在電信和計算機網絡領域，ASN.1（Abstract Syntax Notation One) 是一套標準，是描述數據的表示、編碼、傳輸、解碼的靈活的記法。它提供了一套正式、無歧義和精確的規則以描述獨立於特定計算機硬體的對象結構。</p></blockquote><p>維基總是講得很抽象，我們可以用一句話解決它，那就是：</p><blockquote><p>一種抽象定義資料結構的方法。</p></blockquote><p>我們寫程式宣告變數的時候，最重要的就是需要知道我們這個變數是什麼型別。這也可以對比到ASN.1上面的資料類別。</p><p><img src="https://i.imgur.com/edD0CJ3.png" alt="ASN.1_sample"></p><p>根據這個範例，我們可以看出來，ASN.1就純粹只是資料結構的定義。</p><p>那麼，真正的實作呢？就交給BER、DER這些格式吧！</p><p>實作的時候，以我們的範例來說，它整個是一個<code>SEQUENCE</code>，值就是裏面的兩個元素，分別是<code>INTEGER</code>跟<code>IA5String</code>，值分別是<code>5</code>跟<code>Anybody there?</code>。</p><h5 id="憑證解析"><a href="#憑證解析" class="headerlink" title="憑證解析"></a>憑證解析</h5><hr><p>有了前面的背景知識後，我們對那些binary資料已經不陌生了。</p><p>終於可以開始解析這張憑證了。</p><p>這邊推薦一個實用的網站，可以拿來線上解析ASN.1，叫做<a href="https://lapo.it/asn1js">ASN.1<br> JS</a>，這邊用的憑證範例就是從上面拉過來的。</p><p>我們可以把上面一開始看到的憑證整個貼過去解碼，就可以得到以ASN.1的格式表示的憑證。</p><p><img src="https://i.imgur.com/9mtsLQs.png" alt="cert"></p><h6 id="Object-Identifier"><a href="#Object-Identifier" class="headerlink" title="Object Identifier"></a>Object Identifier</h6><hr><p>我們看圖片，如果只看Type會發現，有個東西之前沒看過，那就是OBJECT IDENTIFIER（OID）。</p><p>OID就是由國際組織定義的唯一識別碼，<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2JqZWN0X2lkZW50aWZpZXI=">維基百科<i class="fa fa-external-link-alt"></i></span>有寫編碼規則。</p><p>那爲什麼要有這個唯一識別碼呢？</p><p>我們知道電腦的世界都是二進位，所以文字也得二進位表示，那最方便的就是數字。我們傳送前事先定義好這些數字代表什麼再傳送，接收方就可以按照定義去解析這些數字，也就是唯一識別碼。</p><h6 id="憑證欄位"><a href="#憑證欄位" class="headerlink" title="憑證欄位"></a>憑證欄位</h6><hr><p>我們先看來看看一張健全的X.509 v3憑證裏面有什麼東西，再對應到剛剛範例中。</p><ul><li>version<br>  憑證的版本。</li><li>serialNumber<br>  憑證的序號，可以是任意的值，只要是唯一即可。</li><li>signature<br>  CA對這張憑證簽章的時候是使用什麼演算法。<ul><li>algorithm<br>  簽章使用的演算法。</li><li>parameters<br>  簽章演算法需要的參數。</li></ul></li><li>issuer<br>  發起這個憑證的人或組織是誰，通常會寫組織名字（organizationName）跟一般稱呼（commonName）。</li><li>validity<br>  一張憑證的有效期限。<ul><li>notBefore<br>  在這之前無效。</li><li>notAfter<br>  在這之後無效。</li></ul></li><li>subject<br>  這張憑證是要頒給誰的，通常會寫國家（countryName）、組織名稱（organizationName）及一般稱呼（commonName）。</li><li>subjectPublicKeyInfo<br>  申請人的公鑰資訊。<ul><li>algorithm<br>  公鑰是適用於哪種非對稱加密演算法的。</li><li>subjectPublicKey<br>  公鑰是什麼。</li></ul></li><li>issuerUniqueID（Optional）<br>  憑證發起者的唯一ID。</li><li>subjectUniqueID（Optional）<br>  申請人的唯一ID。</li><li>extensions<br>  擴充欄位。</li><li>signatureAlgorithm<br>  對憑證簽章使用的演算法。</li><li>signatureValue<br>  簽章值，也就是CA對這張憑證簽出來的值。</li></ul><p>看到上面的列表會發現，也太複雜，根本看不懂這些欄位要幹嘛！</p><p>我們接下來一一稍微詳細介紹一下欄位的用途，然後範例的code block爲了避免眼花，所以在markdown借用js渲染。</p><ul><li><p>version<br>  憑證的版本，總共有3版，以十六進位表示：<code>0x0</code>、<code>0x1</code>、<code>0x2</code>。<br>  <code>INTEGER 2</code></p></li><li><p>serialNumber<br>  憑證的序號，可以是任意的值，只要是唯一即可。RFC內定義最長只能有20 bytes。<br>  <code>INTEGER (124 bit) 13298795840390663119752826058995181320</code></p></li><li><p>signature<br>  CA對這張憑證簽章的時候是使用什麼演算法。</p><ul><li>algorithm<br>  簽章使用的演算法。<br><code>OBJECT IDENTIFIER 1.2.840.113549.1.1.11 sha256WithRSAEncryption (PKCS #1)</code></li><li>parameters<br>  簽章演算法需要的參數。大多時候都是<code>null</code>，以binary表示就是<code>05 00</code>。</li></ul></li><li><p>issuer<br>  發起這個憑證的人或組織是誰，通常會寫組織名字（organizationName）跟一般稱呼（commonName）。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  SET (<span class="number">1</span> elem)</span><br><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.4</span><span class="number">.10</span> organizationName (X<span class="number">.520</span> DN component)</span><br><span class="line">  PrintableString Digital Signature Trust Co.</span><br><span class="line">  SET (<span class="number">1</span> elem)</span><br><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.4</span><span class="number">.3</span> commonName (X<span class="number">.520</span> DN component)</span><br><span class="line">  PrintableString DST Root CA X3</span><br></pre></td></tr></table></figure></li><li><p>validity<br>  一張憑證的有效期限。</p><ul><li>notBefore<br>  在這之前無效。</li><li>notAfter<br>  在這之後無效。</li></ul><p>  白話就是在這期間有效。</p><p>  我覺得這邊比較奇葩的就是這個，爲什麼不寫After跟Before就好，硬要在前面加個not，感覺就很有事。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  UTCTime <span class="number">2016</span>-<span class="number">03</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">46</span> UTC</span><br><span class="line">  UTCTime <span class="number">2021</span>-<span class="number">03</span>-<span class="number">17</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">46</span> UTC</span><br></pre></td></tr></table></figure><p>  這邊範例要注意的是，上面明明就是寫2016-03-17之類的這種時間，爲什麼是UTCTime？這邊沒爲什麼，只是因爲parse成這樣比較好看。<br>  實際上還是一坨binary，但要注意的是UTCTime這個格式是有坑的，而且內容是要用ASCII解碼。</p><p>  根據<span class="exturl" data-url="aHR0cHM6Ly93d3cub2JqLXN5cy5jb20vYXNuMXR1dG9yaWFsL25vZGUxNS5odG1s">這邊<i class="fa fa-external-link-alt"></i></span>說的：</p><blockquote><p>UTCTime values take the form of either “YYMMDDhhmm[ss]Z” or “YYMMDDhhmm[ss](+|-)hhmm”. The first form indicates (by the literal letter “Z”) UTC time. The second form indicates a time that differs from UTC by plus or minus the hours and minutes represented by the final “hhmm”.</p></blockquote><p>  它其實只有YY，並不是YYYY。那如果我們要YYYY，就必須使用GeneralizedTime，<span class="exturl" data-url="aHR0cHM6Ly93d3cub2JqLXN5cy5jb20vYXNuMXR1dG9yaWFsL25vZGUxNC5odG1s">這邊<i class="fa fa-external-link-alt"></i></span>有介紹：</p><blockquote><p>Type GeneralizedTime takes values of the year, month, day, hour, time, minute,second, and second fraction in any of three forms.</p><ol><li> Local time only. ``YYYYMMDDHH[MM[SS[.fff]]]‘’, where the optional fff is accurate to three decimal places.</li><li> Universal time (UTC time) only. ``YYYYMMDDHH[MM[SS[.fff]]]Z’’.</li><li> Difference between local and UTC times. ``YYYYMMDDHH[MM[SS[.fff]]]+-HHMM’’.</li></ol></blockquote><p>  那有個問題是，爲什麼要分成兩種格式？</p><p>  這是因爲一開始設計的人沒想過人類竟然會活過西元2000年。（並沒有<br>  其實是因爲以前電腦記憶體很珍貴，要盡量減少資源消耗，所以才把西元年縮減成兩位，也就是UTCTime（從1950開始）。<br>  但是，後來過2000年發現這東西遲早會遇到Bug，就是萬一時間到2051年就會被表示成1951年，所以才出現GeneralizedTime。</p><p>  所以，RFC裏面也規定憑證在2050之後MUST全面使用GeneralizedTime。</p></li><li><p>subject<br>  這張憑證是要頒給誰的，通常會寫國家（countryName）、組織名稱（organizationName）及一般稱呼（commonName）。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">3</span> elem)</span><br><span class="line">  SET (<span class="number">1</span> elem)</span><br><span class="line">    SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">      OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.4</span><span class="number">.6</span> countryName (X<span class="number">.520</span> DN component)</span><br><span class="line">      PrintableString US</span><br><span class="line">  SET (<span class="number">1</span> elem)</span><br><span class="line">    SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">      OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.4</span><span class="number">.10</span> organizationName (X<span class="number">.520</span> DN component)</span><br><span class="line">      PrintableString Let<span class="string">&#x27;s Encrypt</span></span><br><span class="line"><span class="string">  SET (1 elem)</span></span><br><span class="line"><span class="string">    SEQUENCE (2 elem)</span></span><br><span class="line"><span class="string">      OBJECT IDENTIFIER 2.5.4.3 commonName (X.520 DN component)</span></span><br><span class="line"><span class="string">      PrintableString Let&#x27;</span>s Encrypt Authority X3</span><br></pre></td></tr></table></figure></li><li><p>subjectPublicKeyInfo<br>  申請人的公鑰資訊。</p><ul><li>algorithm<br>  公鑰是適用於哪種非對稱加密演算法的。</li><li>subjectPublicKey<br>  公鑰是什麼。</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">    OBJECT IDENTIFIER <span class="number">1.2</span><span class="number">.840</span><span class="number">.113549</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span> rsaEncryption (PKCS #<span class="number">1</span>)</span><br><span class="line">    NULL</span><br><span class="line">  BIT STRING (<span class="number">2160</span> bit) <span class="number">0011000010000010000000</span>…</span><br><span class="line">    SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">      INTEGER (<span class="number">2048</span> bit) <span class="number">197972484760754376823558522464922272</span>…</span><br><span class="line">      INTEGER <span class="number">65537</span></span><br></pre></td></tr></table></figure><p>  這個範例我們可以看到它適用於RSA，然後底下的金鑰有2048 bit，也就是RSA-2048。另外，我們可以發現65537，就是我們上次說的RSA中公鑰(N, e)裏面<code>e</code>。</p><p>  問題是爲什麼是65537？<br>  這邊我就不詳細說明了，有興趣的可以參考<span class="exturl" data-url="aHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxMTAvaW1wYWN0cy1vZi1ub3QtdXNpbmctcnNhLWV4cG9uZW50LW9mLTY1NTM3LzMxMTM=">這邊<i class="fa fa-external-link-alt"></i></span>。</p></li><li><p>issuerUniqueID（Optional）<br>  憑證發起者的唯一ID。</p><p>  RFC裏面有提到</p><blockquote><p>   If present, version MUST be v2 or v3.</p></blockquote><p>  這是選填欄位，然後這張憑證沒有這個欄位，</p><p>  而且這其實是版本2的憑證才有的東西，v3是爲了兼容才放上去定義。<br>  當初v1沒有這個欄位，所以會出現issuer或是subject完全重複的問題，才更新憑證版本去添加這個欄位。</p><p>  那什麼是重複呢？我們先看看這個情境：</p><blockquote><p>假設今天有一間公司叫A，它向某CA申請憑證，但A最後無情倒閉了。後來又有一間新公司也叫A，也向某CA申請憑證。</p></blockquote><p>  這個問題會變成雖然CA可以按照憑證編號去判斷，但也只能判斷是發出的不同張憑證，卻無法判斷故事中A到底是舊的還是新的，也就是因爲這樣才需要唯一識別的方式。</p></li></ul><ul><li><p>subjectUniqueID（Optional）<br>  申請人的唯一ID。</p><p>  RFC裏面有提到</p><blockquote><p>   If present, version MUST be v2 or v3.</p></blockquote><p>  這也是選填欄位，然而這張憑證也沒有這個欄位，</p><p>  至於爲什麼有這個欄位，在剛剛有提到過。</p></li><li><p>extensions<br>  擴充欄位。</p><p>  RFC裏面有提到</p><blockquote><p>   If present, version MUST be v3.</p></blockquote><p>  當初v2是因爲要新增兩個欄位才改版，但後來發現只要新增一個擴充欄位，裏面添加再多新欄位都不用改版了，因此才出現v3。</p><p>  這個擴充欄位裏面的額外添加物可多了，這邊就不一一介紹，我們只看範例憑證裏面有的東西。</p><ul><li><p>basicConstraints<br>  基本限制，裏面有兩個欄位，分別是：</p><ol><li>這張憑證的Subject是否爲CA，還是EE，預設是false，也就是不是CA。</li><li>(Optional) 這張憑證底下的憑證鏈允許有多少CA，也就是憑證鏈的深度，如果寫1的話，代表著底下可以有無限多個CA；如果是EE憑證的話，因爲是終端，可以不用寫。</li></ol><p>  詳細的解說可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cucGtpc29sdXRpb25zLmNvbS9iYXNpYy1jb25zdHJhaW50cy1jZXJ0aWZpY2F0ZS1leHRlbnNpb24v">這邊<i class="fa fa-external-link-alt"></i></span>。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">3</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.19</span> basicConstraints (X<span class="number">.509</span> extension)</span><br><span class="line">  BOOLEAN <span class="literal">true</span></span><br><span class="line">  OCTET STRING (<span class="number">8</span> byte) 30060101FF020100</span><br><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  BOOLEAN <span class="literal">true</span></span><br><span class="line">  INTEGER <span class="number">0</span></span><br></pre></td></tr></table></figure><p>  這個範例我這邊有點疑問，就是裏面有兩個True。<br>  第一個True是確認是否Subject爲CA，但第二個True呢？<br>  而且第二個欄位爲什麼是SEQUENCE，不是INTEGER嗎？</p><p>  爲了確認這個問題，我去搜尋沒發現有人有這個疑問，然後我撈了其他憑證來對照發現有些明明不是發給CA的憑證，外面的BOOLEAN竟然是true。還有些外面是true，然後SEQUENCE是<code>30 00</code>，也就是長度0的SEQUENCE。這也代表它有定義basicConstraints這個欄位，但想用預設值。</p><p>  目前這個答案是我猜測的，我猜它外面的true應該是想表示它有這個欄位，然後欄位內容接下來以<code>OCTET STRING</code>表示。</p><p>  如果有人有找到或是知道精確的答案，再麻煩留言告訴我，謝謝！</p></li><li><p>keyUsage<br>  定義金鑰用途。<br>  欄位除了定義OID之外還有一個BIT STRING欄位用來表示這張憑證的公鑰能夠做的事情。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id-ce-keyUsage OBJECT IDENTIFIER ::= &#123; id-ce <span class="number">15</span> &#125;</span><br><span class="line"><span class="attr">KeyUsage</span> ::= BIT STRING &#123;</span><br><span class="line">digitalSignature (<span class="number">0</span>),</span><br><span class="line">nonRepudiation (<span class="number">1</span>), -- recent editions <span class="keyword">of</span> X<span class="number">.509</span> have -- renamed <span class="built_in">this</span> bit to contentCommitment</span><br><span class="line">keyEncipherment (<span class="number">2</span>),</span><br><span class="line">dataEncipherment (<span class="number">3</span>),</span><br><span class="line">keyAgreement (<span class="number">4</span>),</span><br><span class="line">keyCertSign (<span class="number">5</span>),</span><br><span class="line">cRLSign (<span class="number">6</span>),</span><br><span class="line">encipherOnly (<span class="number">7</span>),</span><br><span class="line">decipherOnly (<span class="number">8</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在<span class="exturl" data-url="aHR0cHM6Ly9sZGFwd2lraS5jb20vd2lraS9LZXlVc2FnZQ==">這邊<i class="fa fa-external-link-alt"></i></span>有更詳細的說明。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">3</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.15</span> keyUsage (X<span class="number">.509</span> extension)</span><br><span class="line">  BOOLEAN <span class="literal">true</span></span><br><span class="line">  OCTET STRING (<span class="number">4</span> byte) <span class="number">03020186</span></span><br><span class="line">    BIT STRING (<span class="number">7</span> bit) <span class="number">1000011</span></span><br></pre></td></tr></table></figure><p>   這邊範例也有一樣的<code>BOOLEAN true</code>，跟上一項一樣我也不知道爲什麼，但推測可能是想表示它這項是有內容的。</p></li><li><p>authorityInfoAccess<br>  可向頒發此憑證的CA取得的額外資訊。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.5</span><span class="number">.5</span><span class="number">.7</span><span class="number">.1</span><span class="number">.1</span> authorityInfoAccess (PKIX private extension)</span><br><span class="line">  OCTET STRING (<span class="number">115</span> byte) 3071303206082B060105050730018626…</span><br><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">OBJECT IDENTIFIER <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.5</span><span class="number">.5</span><span class="number">.7</span><span class="number">.48</span><span class="number">.1</span> ocsp (PKIX)</span><br><span class="line">[<span class="number">6</span>] (<span class="number">38</span> byte) http:<span class="comment">//isrg.trustid.ocsp.identrust.com</span></span><br><span class="line">  SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">OBJECT IDENTIFIER <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.5</span><span class="number">.5</span><span class="number">.7</span><span class="number">.48</span><span class="number">.2</span> caIssuers (PKIX subject/authority info access descriptor)</span><br><span class="line">[<span class="number">6</span>] (<span class="number">47</span> byte) http:<span class="comment">//apps.identrust.com/roots/dstrootcax3.p7c</span></span><br></pre></td></tr></table></figure><p>  從範例來看，我們可以看到這個CA提供了兩項服務，OSCP跟caIssuers。</p><p>  OCSP就是一種線上詢問憑證狀態的方法，比起CRL清單來得不受限更新時間，但會對被詢問方造成負擔（當然，狂問就等於DDoS了）。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlDJUE4JUU3JUJBJUJGJUU4JUFGJTgxJUU0JUI5JUE2JUU3JThBJUI2JUU2JTgwJTgxJUU1JThEJThGJUU4JUFFJUFF">維基百科<i class="fa fa-external-link-alt"></i></span>也有頁面說明。然後，我們看範例就可以知道它提供的OCSP查詢位置是<code>http://isrg.trustid.ocsp.identrust.com</code>。</p></li><li><p>authorityKeyIdentifier(AKI)<br>  取自issuer CA的Public key經由SHA-1 Hash value做為Key的identifier。<br>  這個做法比起版本2的Issuer UID來說，還多了一項資訊，就是我目前這張憑證究竟來自哪張憑證，而不是只有唯一的一個Issuer UID。<br>  對應方法就是AKI會等於上一層憑證的subjectKeyIdentifier(SKI)。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.35</span> authorityKeyIdentifier (X<span class="number">.509</span> extension)</span><br><span class="line">  OCTET STRING (<span class="number">24</span> byte) 30168014C4A7B1A47B2C71FADBE14B9075FFC41560858910</span><br></pre></td></tr></table></figure></li><li><p>subjectKeyIdentifier(SKI)<br>  取自Subject的Public key經由經由SHA-1 Hash value做為Key的identifier。<br>  SKI如剛剛所說的，如果有下一層憑證的話，會變成下一層憑證的AKI。以此形成一個一層層憑證鏈的對應關係。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.14</span> subjectKeyIdentifier (X<span class="number">.509</span> extension)</span><br><span class="line">  OCTET STRING (<span class="number">22</span> byte) 0414A84A6A63047DDDBAE6D139B7A64565EFF3A8ECA1</span><br></pre></td></tr></table></figure><p>  這邊有一張範例圖，看了可能會比較瞭解：</p><p>  <img src="https://i.imgur.com/mQjOBte.png" alt="aki_ski"></p></li><li><p>certificatePolicies<br>  當初CA基於怎樣的規範發這張憑證，<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kb2NzL2VuL3pvcy8yLjIuMD90b3BpYz1jdXN0b21pemF0aW9uLXVzaW5nLWNlcnRpZmljYXRlLXBvbGljaWVz">這邊<i class="fa fa-external-link-alt"></i></span>有提到：</p><blockquote><p>This extension contains policy information, such as how your CA operates and the intended purpose of the issued certificates.</p></blockquote>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.32</span> certificatePolicies (X<span class="number">.509</span> extension)</span><br><span class="line">  OCTET STRING (<span class="number">77</span> byte) 304B3008060667810C010201303F0…</span><br><span class="line">    SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  SEQUENCE (<span class="number">1</span> elem)</span><br><span class="line">    OBJECT IDENTIFIER <span class="number">2.23</span><span class="number">.140</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">  SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">    OBJECT IDENTIFIER <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.44947</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    SEQUENCE (<span class="number">1</span> elem)</span><br><span class="line">  SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">    OBJECT IDENTIFIER <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.5</span><span class="number">.5</span><span class="number">.7</span><span class="number">.2</span><span class="number">.1</span> cps (PKIX policy qualifier)</span><br><span class="line">    IA5String http:<span class="comment">//cps.root-x1.letsencrypt.org</span></span><br></pre></td></tr></table></figure><p>  範例如果把它parse成字串的話，會變成：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1]Certificate Policy:</span><br><span class="line">    Policy Identifier=2.23.140.1.2.1</span><br><span class="line">[2]Certificate Policy:</span><br><span class="line">Policy Identifier=1.3.6.1.4.1.44947.1.1.1</span><br><span class="line">[2,1]Policy Qualifier Info:</span><br><span class="line">Policy Qualifier Id=CPS</span><br><span class="line">Qualifier:</span><br><span class="line">http://cps.letsencrypt.org</span><br></pre></td></tr></table></figure><p>  這邊我們可以看出有兩個OID：</p><ol><li><code>2.23.140.1.2.1</code><br> 這個是表示DN（domain name），我們可以在<span class="exturl" data-url="aHR0cDovL29pZC1pbmZvLmNvbS9nZXQvMi4yMy4xNDAuMS4yLjE=">OID info<i class="fa fa-external-link-alt"></i></span>上面查到登記這個OID的相關資料。</li><li><code>1.3.6.1.4.1.44947.1.1.1</code><br> 這間企業向國際組織申請的唯一編號，又被稱爲PEN（Private Enterprise Number）。</li></ol><p>  然後，<code>Policy Qualifier Info</code>裏面指的CPS就是『憑證實務作業基準』。CA會根據這個基準去管理憑證，也算是一種憑證頒發者聲明。</p><p>  詳細可以參考這邊<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3lzYWRtaW5zLmx2L2Jsb2ctZW4vY2VydGlmaWNhdGUtcG9saWNpZXMtZXh0ZW5zaW9uLWFsbC15b3Utc2hvdWxkLWtub3ctcGFydC0xLmFzcHg=">Certificate Policies extension – all you should know Part1<i class="fa fa-external-link-alt"></i></span>跟<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3lzYWRtaW5zLmx2L2Jsb2ctZW4vY2VydGlmaWNhdGUtcG9saWNpZXMtZXh0ZW5zaW9uLWFsbC15b3Utc2hvdWxkLWtub3ctcGFydC0yLmFzcHg=">Certificate Policies extension – all you should know Part2<i class="fa fa-external-link-alt"></i></span>。</p></li><li><p>cRLDistributionPoints<br>  如其名，這個欄位表示CRL的發佈位置。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE (<span class="number">2</span> elem)</span><br><span class="line">  OBJECT IDENTIFIER <span class="number">2.5</span><span class="number">.29</span><span class="number">.31</span> cRLDistributionPoints (X<span class="number">.509</span> extension)</span><br><span class="line">OCTET STRING (<span class="number">53</span> byte) 30333031A02FA02D862B687474703A2F2F637…</span><br><span class="line">SEQUENCE (<span class="number">1</span> elem)</span><br><span class="line">  SEQUENCE (<span class="number">1</span> elem)</span><br><span class="line">[<span class="number">0</span>] (<span class="number">1</span> elem)</span><br><span class="line">  [<span class="number">0</span>] (<span class="number">1</span> elem)</span><br><span class="line">[<span class="number">6</span>] (<span class="number">43</span> byte) http:<span class="comment">//crl.identrust.com/DSTROOTCAX3CRL.crl</span></span><br></pre></td></tr></table></figure><p>  從範例，我們可以看出來這個CA的CRL發佈位置是<code>http://crl.identrust.com/DSTROOTCAX3CRL.crl</code>。</p><p>  詳細可以參考<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kb2NzL2VuL2V4dGVybmFsLWF1dGgtc2VydmVyLzIuNC4zP3RvcGljPWV4dGVuc2lvbnMtY3JsZGlzdHJpYnV0aW9ucG9pbnRzLWV4dGVuc2lvbg==">這邊<i class="fa fa-external-link-alt"></i></span>。</p></li></ul></li><li><p>signatureAlgorithm<br>  對憑證簽章使用的演算法。<br>  <code>OBJECT IDENTIFIER 1.2.840.113549.1.1.11 sha256WithRSAEncryption (PKCS #1)</code></p><p>  等等！剛剛不是裏面出現過一次嗎？</p><p>  主要是因爲簽章爲了把算法也簽進簽章值裏面，所以才會重複出現，這樣也可以達成雙重驗證的效果。</p><p>  這邊<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTE0NzQ2L3doeS1pcy10aGUtc2lnbmF0dXJlLWFsZ29yaXRobS1saXN0ZWQtdHdpY2UtaW4tYW4teDUwOS1jZXJ0aWZpY2F0ZQ==">Why is the Signature Algorithm listed twice in an x509 Certificate?<i class="fa fa-external-link-alt"></i></span>有個答案是說避免一些被攻擊的風險。</p></li><li><p>signatureValue<br>  簽章值，也就是CA對這張憑證簽出來的值。<br>  <code>BIT STRING (2048 bit) 110111010011001111010111000100</code></p><p>  等等！再等等！對這張憑證簽？！所以是簽哪些？</p><p>  我們剛剛說的區塊裏面除了最後的<code>signatureAlgorithm</code>跟<code>signatureValue</code>之外，其他區塊合稱<code>tbsCertificate</code>，其中<code>tbs</code>是<code>to be sign</code>的縮寫，也就是需要被簽的區塊。</p></li></ul><p>最後，這邊有一張從ASN.1定義到最後PEM格式的憑證流程圖可以看看，引用自<span class="exturl" data-url="aHR0cHM6Ly9kYXJ1dGsubWVkaXVtLmNvbS9pbGx1c3RyYXRlZC14LTUwOS1jZXJ0aWZpY2F0ZS04NGFlY2UyYzVjMmU=">Illustrated X.509 Certificate<i class="fa fa-external-link-alt"></i></span>：</p><p><img src="https://miro.medium.com/max/2400/1*ShM4dle1AXnR9pvZ1gTKfA.png" alt="app"></p><p>以上就是憑證的欄位解析，如果你都有看完，那我們就看完現役的一張完整憑證了，恭喜你。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><hr><p>這一次資訊量很大，上次有提到密碼學，這次應用密碼學中的非對稱加密來做簽驗章，以此驗證不可否認性以及完整性。</p><p>再來，因爲無法單從公鑰分辨身份，需要第三方去背書，因此有了憑證。<br>最後，我們直接剖析一張完整的憑證來看看憑證裏面到底裝了些什麼。</p><p>從這邊就可以知道我們習以爲常的網路安全背後有很複雜的原理，無時無刻，每天都在作用。</p><p>那麼，學會了這些有什麼用呢？</p><p>很遺憾，在一般生活中也沒什麼用。頂多跟朋友聊天的時候可以打打嘴砲說我可以用肉眼解析憑證的二進位格式之類的。</p><p>不過在工作上，如果是做資安相關的人或許會有點用吧。</p><p>最後，關於簽驗章跟憑證，更詳細的說明可以參考<span class="exturl" data-url="aHR0cDovL3d3dy50c25pZW4uaWR2LnR3L1NlY3VyaXR5X1dlYkJvb2svJUU3JUFDJUFDJUU0JUI4JTgzJUU3JUFCJUEwJTIwJUU2JTk1JUI4JUU0JUJEJThEJUU3JUIwJUJEJUU3JUFCJUEwJUU4JTg4JTg3JUU2JTk1JUI4JUU0JUJEJThEJUU2JTg2JTkxJUU4JUFEJTg5Lmh0bWw=">這邊<i class="fa fa-external-link-alt"></i></span>，然後ASN.1、BER跟DER可以參考<span class="exturl" data-url="aHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1s">A Layman’s Guide to a Subset of ASN.1, BER, and DER<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="圖片串"><a href="#圖片串" class="headerlink" title="圖片串"></a>圖片串</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vYS9lc2VDd3kw">這次用到的簽驗章截圖imgur存放區<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vYS9HUzdLNWxP">這次用到的憑證截圖imgur存放區<i class="fa fa-external-link-alt"></i></span></p><h2 id="尾語"><a href="#尾語" class="headerlink" title="尾語"></a>尾語</h2><hr><p>這邊有個悲報就是這是這系列最後一集。</p><p>因爲我離職了，未來很高機率不會再碰到這些知識。</p><p>感謝某公司讓我花時間自學這些以前沒想過的冷門知識，也感謝前輩願意指導。</p><p>沒想到會因爲人的關係離開，我一直覺得工作上可以互相尊重是件很重要的事情。</p><p>有人喜歡堅持己見，強硬又還一副自以爲對你好的態度，說話只會冷嘲熱諷還預設立場，連溝通都沒辦法。</p><p>期許自己未來不會變成這種老害，也希望下一份工作能更好。😥</p><p>最後，這次的內容如果有問題也歡迎留言討論。</p><p>如果要轉載的話，再麻煩標註作者跟網址，謝謝！ 😊</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;上次提到的加密演算法『公鑰加密，私鑰解密』達成了PKI中傳遞資料的隱密性，以及雜湊演算法的低碰撞性可以檢查傳遞資料的完整性。&lt;/p&gt;
&lt;p&gt;那麼，身份鑑別跟不可否認性呢？我們來看看『私鑰加密，公鑰解密』，簽驗章流程與憑證是什麼。&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="cryptograph" scheme="http://natlee.github.io/Blog/tags/cryptograph/"/>
    
    <category term="security" scheme="http://natlee.github.io/Blog/tags/security/"/>
    
    <category term="signature" scheme="http://natlee.github.io/Blog/tags/signature/"/>
    
    <category term="certificate" scheme="http://natlee.github.io/Blog/tags/certificate/"/>
    
    <category term="encoding" scheme="http://natlee.github.io/Blog/tags/encoding/"/>
    
    <category term="decoding" scheme="http://natlee.github.io/Blog/tags/decoding/"/>
    
  </entry>
  
  <entry>
    <title>資安常識(2) - 對稱非對稱加密演算法與雜湊算法</title>
    <link href="http://natlee.github.io/Blog/posts/1489926540/"/>
    <id>http://natlee.github.io/Blog/posts/1489926540/</id>
    <published>2021-09-29T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>接續上次的PKI，我們知道有件事是資安裏面一定會遇到的事！</p><p>也就是大家的密碼絕對不會用明文呈現。</p><p>那麼，我們要如何把一段明文變成密碼呢？</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><p>把一段明文變成密碼，我們要做的就是<code>加密</code>；相反則是把密文變回明文，也就是<code>解密</code>。</p><p>另外，這邊要注意的是，有些人聽過<code>雜湊</code>，但是加解密跟雜湊是完全不一樣的東西！</p><p>一段文字（或資料）經過雜湊是不能變回去原本的資料的，因爲原始內容已經經過不斷壓縮破壞才變成長度一致的雜湊值。其中，怎麼破壞要看每個雜湊函數的定義。</p><p>就跟生米煮成熟飯一樣不能把飯變回米粒一樣。</p><p>那麼，我們之前常聽到的對稱與非對稱加密演算法屬於現代密碼學的範疇。</p><p>在密碼學裏面有分爲古典密碼學跟現在密碼學，我們先分別理解一下差異。</p><h3 id="古典密碼學"><a href="#古典密碼學" class="headerlink" title="古典密碼學"></a>古典密碼學</h3><hr><p>以前的加密手法被稱爲隱寫術，根據<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJUE0JUU1JTg1JUI4JUU1JUFGJTg2JUU3JUEyJUJD">維基百科<i class="fa fa-external-link-alt"></i></span>的描述：</p><blockquote><p><strong>古典密碼</strong>是密碼學中的其中一個類型，其大部分加密方式都是利用替換式密碼或移項式密碼，有時則是兩者的混合。其於歷史中經常使用，但現代已經很少使用，大部分的已經不再使用了。一般而言，經典密碼是基於一個拼音字母（像是 A-Z）、動手操作或是簡單的裝置。它們可能是一種簡單的密碼法，以致於不可信賴的地步，特別是有新技術被發展出來後。</p></blockquote><p>我們可以瞭解到以前的密碼大多是用移形換位法來達成加密的目的。</p><p>加密使用移形換位法的話，我們只要再反向操作就能從密文推回明文了。</p><h4 id="凱撒密碼"><a href="#凱撒密碼" class="headerlink" title="凱撒密碼"></a>凱撒密碼</h4><hr><p>以維基百科的例子，我們來看看凱撒密碼。</p><p>凱撒密碼是一種替換式密碼，我們把明文的字母 a-z 打亂，再做一一對應，就可以達成凱撒加密了。</p><blockquote><p><strong>一般字母</strong>: a b c d e f g h i j k l m n o p q r s t u v w x y z<br><strong>密碼字母</strong>: c i p h e r s t u v w x y z a b d f g j k l m n o q</p></blockquote><p>像是這串明文<code>hello</code>，我們可以把它換成密文<code>texxa</code>。</p><p>除此之外，也有其他加密方式，幾乎都大同小異。</p><p>這種加密方式，我們很容易能夠透過統計分析密文來解析出明文。</p><p>例如，英文裏面最常出現的介系詞、助詞、冠詞都可以拿來當做高頻率單字來提供解析線索。</p><p>所以，不想被簡單破解就得使用現代手段。</p><h3 id="現代密碼學"><a href="#現代密碼學" class="headerlink" title="現代密碼學"></a>現代密碼學</h3><hr><p>現代密碼學主要是由電腦的出現，進而改變以前對密碼的認知。</p><p>以前人覺得密碼只要讓不知情的人看不懂就好，設計的人會運用自己的創意來製造加密方式。但這樣的方式容易讓有心人士察覺並破解，其實並不安全。</p><p>現代密碼強調的是『如何在充滿敵人的環境來傳遞資訊』，也就是說任何人都可以看到我的密文，但他們都沒辦法破譯。</p><p>因此，我們如果有一把共同持有的鑰匙去加密的話，你知道我知道，加解密都用同一把鑰匙。這樣加密後傳送，就算有人攔截密文也沒辦法看懂內容，這就是對稱式加密。</p><p>但是，如何傳遞這把鑰匙就成了一個安全問題。</p><p>後來則衍生出，我有一把公開的鑰匙，大家都可以取得；另一把非公開的鑰匙，只有我擁有。這樣兩把鑰匙，公開的叫公鑰，非公開的叫私鑰，兩把都可以拿來加解密，分別有不同的含義，這就是非對稱式加密的方法。</p><p>這時候就有一個問題，這樣講非對稱好像比對稱還厲害？爲什麼現在還在用對稱加密？</p><p>其實，非對稱加密有一些弊病存在，像是加密速度因爲數學運算導致相較於對稱加密來得慢，所以現在大多的加密手法都是混合對稱與非對稱來進行加密，也稱爲混合加密。</p><p>接下來，我們分別看看一些常見的對稱式與非對稱加密方法，而這些方法都是採用區塊加密。</p><p>那麼，區塊加密的意思是明文切成同金鑰長度的一塊塊資料塊對著金鑰進行加密。</p><p>其中，區塊加密方式有分成很多種不同的分塊方式，有興趣的可以參見<span class="exturl" data-url="aHR0cHM6Ly9ub3Rlcy5hbmR5d3UudHcvMjAxOS8lRTUlQUYlODYlRTclQTIlQkMlRTclOUElODQlRTUlOEElQTAlRTUlQUYlODYlRTYlQTglQTElRTUlQkMlOEZlY2ItY2JjLWNmYi1vZmItY3RyLw==">這邊的解說<i class="fa fa-external-link-alt"></i></span>。</p><h4 id="對稱式加密"><a href="#對稱式加密" class="headerlink" title="對稱式加密"></a>對稱式加密</h4><hr><p>區塊對稱加密的算法有很多種，這邊提出兩個比較常見的例子。</p><h5 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h5><hr><p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUIzJTg3JUU2JTk2JTk5JUU1JThBJUEwJUU1JUFGJTg2JUU2JUE4JTk5JUU2JUJBJTk2">維基百科<i class="fa fa-external-link-alt"></i></span>的描述：</p><blockquote><p>資料加密標準（Data Encryption Standard, DES）是一種對稱密鑰加密塊密碼演算法，1976年被美國聯邦政府的國家標準局確定為聯邦資料處理標準（FIPS），隨後在國際上廣泛流傳開來。它基於使用56位金鑰的對稱演算法。這個演算法因為包含一些機密設計元素，相對短的金鑰長度以及懷疑內含美國國家安全局（NSA）的後門而在開始時有爭議，DES因此受到了強烈的學院派式的審查，並以此推動了現代的塊密碼及其密碼分析的發展。</p></blockquote><p>從以上內容，我們可以得到一些資訊，DES的金鑰是56 bits，但DES每一個加密區塊是64 bits。</p><p>問題來了，不是說好金鑰長度要跟區塊一樣長嗎？</p><p>其中，有 8 bits 是同位元檢查碼，是用來檢出錯誤，所以真正用來加密的長度只有 56 bits。</p><p>運算的時候，會把鑰匙折一半得到一對各32 bits的子鑰匙並分別對也被折半的區塊加密。</p><p>那麼，如果資料短於 64 bits 怎麼辦？</p><p>有一種手法叫做<strong>padding</strong>，它加密前會將資料填補<code>0</code>，讓長度剛好能夠被64整除。</p><p>詳細算法流程可以<span class="exturl" data-url="aHR0cDovL3d3dy50c25pZW4uaWR2LnR3L1NlY3VyaXR5X1dlYkJvb2svY2hhcDIvMi04JTIwREVTJTIwJUU1JUFGJTg2JUU3JUEyJUJDJUU3JUIzJUJCJUU3JUI1JUIxLmh0bWw=">參照這裏<i class="fa fa-external-link-alt"></i></span>。</p><h5 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h5><hr><p>這個算法又稱Rijndael演算法，是美國國家安全局NIST有鑑於DES被發現不安全且被破解，於是公開徵求加密演算法，於是產生了這個進階加密標準（Advanced Encryption Standard, AES）加密演算法。</p><p>它跟DES有根本上的不同，它把金鑰變資料塊變成矩陣來進行加密運算。</p><p>詳細算法流程可以<span class="exturl" data-url="aHR0cDovL3d3dy50c25pZW4uaWR2LnR3L1NlY3VyaXR5X1dlYkJvb2svY2hhcDIvMi0xMCUyMEFFUyUyMCVFNSVBRiU4NiVFNyVBMiVCQyVFNiVBOCU5OSVFNiVCQSU5Ni5odG1s">參照這裏<i class="fa fa-external-link-alt"></i></span>。</p><h4 id="非對稱式加密"><a href="#非對稱式加密" class="headerlink" title="非對稱式加密"></a>非對稱式加密</h4><hr><p>區塊非對稱加密的算法也有很多種，這邊也提出兩個比較常見的例子。</p><h5 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h5><hr><p>這個加密算法可以用比較簡單的方式描述。</p><p>首先，我們要產生一對公私鑰：</p><ol><li>選擇兩個大的質數： p, q</li><li>計算 N = p ꞏ q</li><li>計算 r = ɸ(N) = ɸ(p) ɸ(q) = (p-1)(q-1)</li><li>找一個小於 r 且互質的整數 e</li><li>找 e 的mod倒數 d 使 e ꞏ d ≡ 1 (mod r)</li><li>獲得公鑰：(N ,e), 私鑰：(N ,d)</li></ol><p>ɸ(N)是尤拉函數，也就是從1到N，有多少跟N互質的數。<br>假設N是7，我們知道是一個質數，從1到7總共有6個數字1, 2, 3, 4, 5, 6都跟7互質，所以ɸ(7)就等於6。<br>由這邊可以知道當N是質數的話，ɸ(N) 就等於N-1。</p><p>那麼，我們舉一個產生鑰匙的簡單例子來看看：</p><blockquote><p>N = p * q = 47 * 71 = 3337<br>φ(N) = 3220 <em>(46*70)</em><br>找一個和 3220 互質的數字，得鑰匙 (N, e) = (3337, 79)<br>有p、q跟e，得另一個對應的鑰匙 (N, d) = (3337, 1019)</p></blockquote><p>接下來，我們要使用這對鑰匙來進行加解密。</p><p>先搬出公式：</p><blockquote><p>公鑰加密 C ≡（M）^e(mod N)<br>私鑰解密 M ≡（C）^d(mod N)</p></blockquote><p>其中，C是密文(cipher)，M是明文(message)。</p><p>相反的，我們也可以用私鑰加密，公鑰解密：</p><blockquote><p>私鑰加密 C ≡（M）^d(mod N)<br>公鑰解密 M ≡（C）^e(mod N)</p></blockquote><p>我們可以發現兩種不同加解密方式只有<code>d</code>跟<code>e</code>互換而已。</p><p>接著，我們舉一個簡單的範例來看看，但要注意的是實際使用並不會這麼簡單。</p><blockquote><p>有一段明文M以16進位(hex，更細來看也可以說是binary)表示爲 <strong>0069 0073</strong><br>用剛剛範例的公鑰加密，把明文分成兩塊0069跟0073分別加密<br>C1 = <strong>0069</strong>^79 (mod 3337) = 00C1<br>C2 = <strong>0073</strong>^79 (mod 3337) = 02DC<br>最後合併得到結果C = <strong>00C1 02DC</strong><br>解密則是反向操作，拿私鑰解密，會得到原本的明文 0069 0073<br>這邊要注意的是不能比每一塊大小不能比N還大，因爲我們是取餘數，如果比較大的話，根據同餘的計算，加密會加成錯誤的結果，解密當然也會解成錯誤的明文（也就是解密失敗）。</p></blockquote><p>剛剛提到padding，RSA的填充方式也有很多種（還有公私鑰的區別），有全部填FF，還有填亂數的做法。這邊要參照<span class="exturl" data-url="aHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzNDQ3">PKCS#1<i class="fa fa-external-link-alt"></i></span>去瞭解它有哪些填充方式。（我覺得最麻煩的是RSA-OAEP）</p><p>另外，看到這邊就知道加解密不能直接字串去進行數學運算，因爲數學，總是要數字嘛，所以我們得把字串轉成數字。那麼，唯一的方法就是二進位格式。</p><p>最後，還是得強調加解密只是數學運算，並不會因爲無法計算導致無法加解密，而我們是要看結果正不正確才知道成功還是失敗。</p><h5 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h5><hr><p>這個加密演算法加解密速度跟在短金鑰的狀況演算法安全度都勝過RSA，現在不全面改用是因爲專利問題跟一些歷史因素。<br>詳細算法流程可以<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDI1MTAzMQ==">參照這裏<i class="fa fa-external-link-alt"></i></span>。</p><h4 id="何謂安全"><a href="#何謂安全" class="headerlink" title="何謂安全"></a>何謂安全</h4><hr><p>剛剛提到加密演算法的時候，有提到安全問題，那麼什麼是安全？</p><p>安全有分成兩種：</p><ol><li>絕對安全<br> 不管使用任何手段都沒有任何辦法可以破解就是絕對安全。</li><li>相對安全<br> 在有限的資源（包含時間）內，並設定一個範圍，使這段時間內是安全的，這樣就是相對安全。也就是說NIST能夠運用現有資源來推測當前電腦運算速度跟未來發展去判斷RSA-2048到2030年前都是安全的。</li></ol><p>那麼，強度竟然能比較，就會有等級概念，這樣要怎麼分？</p><p>根據<span class="exturl" data-url="aHR0cHM6Ly9jc3JjLm5pc3QuZ292L2dsb3NzYXJ5L3Rlcm0vc2VjdXJpdHlfc3RyZW5ndGg=">NIST官方文件<i class="fa fa-external-link-alt"></i></span>定義安全強度（Security strength）如下：</p><blockquote><p> A number associated with the amount of work (that is, the number of operations) that is required to break a cryptographic algorithm or system. In this policy, security strength is specified in bits and is a specific value from the set {80, 112, 128, 192, 256}.</p></blockquote><p>我們可以看到官方有個強度集合內五個元素<code>&#123;80, 112, 128, 192, 256&#125;</code>，NIST把各個金鑰長度的對稱與非對稱加密推算後，對應到這五個強度。</p><p>這邊會有個問題是我們知道AES可以用暴力破解的數量級來換算（像是AES-128用暴力破解所需嘗試次數爲2^128次，安全強度就是128），那麼RSA這種用餘數定理的數學運算加密要如何換算到這五個強度呢？</p><p>根據<span class="exturl" data-url="aHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzg2ODcvc2VjdXJpdHktc3RyZW5ndGgtb2YtcnNhLWluLXJlbGF0aW9uLXdpdGgtdGhlLW1vZHVsdXMtc2l6ZQ==">這邊<i class="fa fa-external-link-alt"></i></span>有個解答：</p><blockquote><p>Those <em>appear</em> to be based on the complexity of the <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VuZXJhbF9udW1iZXJfZmllbGRfc2lldmU=">General Number Field Sieve<i class="fa fa-external-link-alt"></i></span>, one of the fastest (if not <em>the</em> fastest) classical factoring algorithms. I confirmed this in Mathematica.<br>In the expression, the <strong>n</strong> is a number to factor. Evaluating the expression at <strong>2^b</strong> is a rough approximation of the the time needed to factor a b-bit integer. Here’s a table showing the bit-length of the evaluation at 2^1024, 2^2048,…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Strength  RSA modulus size   Complexity bit-length</span><br><span class="line"> 80        1024              86.76611925028119</span><br><span class="line"> 112       2048              116.8838132958159</span><br><span class="line"> 128       3072              138.7362808527251</span><br><span class="line"> 192       7680              203.01873594417665</span><br><span class="line"> 256       5360              269.38477262128384</span><br></pre></td></tr></table></figure></blockquote><p>從裏面可以看到它根據大數分解最快速的演算法GNFS推算出RSA-2048對應到112安全強度。<span class="exturl" data-url="aHR0cHM6Ly9jc3JjLm5pc3QuZ292L2NzcmMvbWVkaWEvcHJvamVjdHMvY3J5cHRvZ3JhcGhpYy1tb2R1bGUtdmFsaWRhdGlvbi1wcm9ncmFtL2RvY3VtZW50cy9maXBzMTQwLTIvZmlwczE0MDJpZy5wZGY=">Implementation Guidance for FIPS 140-2 and the Cryptographic Module Validation Program<i class="fa fa-external-link-alt"></i></span>的第122頁內也有寫到NIST如何用RSA金鑰長度推算出安全強度的公式，裏面的參數是金鑰長度（應該比較直觀），代入後也是可以得到相近的值。</p><h3 id="雜湊算法"><a href="#雜湊算法" class="headerlink" title="雜湊算法"></a>雜湊算法</h3><hr><p>密碼學上有一個東西叫做訊息摘要(Message digest)，也就是將一串資料（有可能是字串，也可能是數字，反正都可以是binary），透過雜湊演算法計算，得到一組固定長度的字串。</p><p>那麼，這個雜湊算法會有這些特性：</p><ul><li><p>輸入任意長度（其實還是有上限的，像是SHA-1上限是2^64位元長度），輸出爲固定長度</p></li><li><p>原始資料有些許不同，產生的輸出與原先輸出相比會有極大不同</p></li><li><p>強碰撞抵抗力(Strong collision resistance)，也就是不同資料<strong>很難</strong>有相同結果</p></li><li><p>單向函數(One-way function)，函數會破壞資料導致無法反向</p></li></ul><p>雜湊的演算法有很多種，如MD5、SHA-1、SHA-2等等，但這邊就不全部列舉。</p><p>我們直接來看看SHA雜湊是怎麼做的。</p><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><hr><h5 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h5><hr><p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU0hBLTE=">維基百科<i class="fa fa-external-link-alt"></i></span>：</p><blockquote><p>SHA-1（Secure Hash Algorithm 1）是一種密碼雜湊函式，美國國家安全局設計，並由美國國家標準技術研究所（NIST）發布為聯邦資料處理標準（FIPS）。SHA-1可以生成一個被稱為訊息摘要的<strong>160位</strong>（20位元組）雜湊值，雜湊值通常的呈現形式為<strong>40</strong>個十六進位數。</p></blockquote><p>我們可以注意到上面這段的數字，SHA-1可以產生長度爲 160 bits的摘要值是因爲定義中有講到內部有五個32-bit 暫存器。</p><p>那麼，我們看看它的算法是如何做的。</p><p>一開始有五個暫存器的初始值分別爲：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h0 := 0x67452301</span><br><span class="line">h1 := 0xEFCDAB89</span><br><span class="line">h2 := 0x98BADCFE</span><br><span class="line">h3 := 0x10325476</span><br><span class="line">h4 := 0xC3D2E1F0</span><br></pre></td></tr></table></figure><p>這些值是固定的，當初他們定義就是這樣了，但爲什麼數字值是這些，我就沒有特別研究了。</p><p>接著，它會做一些前處理，把輸入的資料切成448-bit的chunk，再padding成512-bit，以確保是512的倍數。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br></pre></td></tr></table></figure><p>再來，因爲演算區塊是512-bit爲單位，所以要把訊息全部切成一塊塊512-bit去做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15</span><br><span class="line"></span><br><span class="line">Extend the sixteen 32-bit words into eighty 32-bit words:</span><br><span class="line">    for i from 16 to 79</span><br><span class="line">        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1</span><br><span class="line"></span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line"></span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 79</span><br><span class="line">        if 0 ≤ i ≤ 19 then</span><br><span class="line">            f := (b and c) or ((not b) and d)</span><br><span class="line">            k := 0x5A827999</span><br><span class="line">        else if 20 ≤ i ≤ 39</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            k := 0x6ED9EBA1</span><br><span class="line">        else if 40 ≤ i ≤ 59</span><br><span class="line">            f := (b and c) or (b and d) or(c and d)</span><br><span class="line">            k := 0x8F1BBCDC</span><br><span class="line">        else if 60 ≤ i ≤ 79</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            **k := 0xCA62C1D6**</span><br><span class="line"></span><br><span class="line">        temp := (a leftrotate 5) + f + e + k + w[i]</span><br><span class="line">        e := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b leftrotate 30</span><br><span class="line">        b := a</span><br><span class="line">        a := temp</span><br><span class="line"></span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們可以看到中間，有個<code>k</code>的變數，如下：</p><blockquote><p>k := 0x5A827999<br>k := 0x6ED9EBA1<br>k := 0x8F1BBCDC<br>k := 0xCA62C1D6</p></blockquote><p>這些在這邊被稱爲鹽（Salt），但爲什麼是這些數字，我也沒研究。</p><p>但是，SHA-1最重要的精髓就是中間那80-round，它把資料壓縮成160-bit，並且在每次迴圈都使用破壞性相加，所以也沒辦法回推初始值是什麼。</p><p>最後再把五個暫存器出來的結果拼起來就變成最終輸出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4</span><br></pre></td></tr></table></figure><p>比較詳細的解說可以<span class="exturl" data-url="aHR0cDovL3d3dy50c25pZW4uaWR2LnR3L1NlY3VyaXR5X1dlYkJvb2svY2hhcDQvNC00JTIwU0hBLTElMjAlRTYlQkMlOTQlRTclQUUlOTclRTYlQjMlOTUuaHRtbA==">參考這邊<i class="fa fa-external-link-alt"></i></span>。</p><p>這邊會有個疑問就是，我們剛剛說因爲五個32-bit暫存器，所以輸出爲160 bits的長度，可是爲什麼一開始維基百科最後一句說輸出其實是四十個十六進位值？</p><p>這個問題在<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzcwNDAxMC93aHktaXMtYS1zaGEtMS1oYXNoLTQwLWNoYXJhY3RlcnMtbG9uZy1pZi1pdC1pcy1vbmx5LTE2MC1iaXQ=">這邊<i class="fa fa-external-link-alt"></i></span>可以找到答案。</p><blockquote><p>One hex character can only represent 16 different values, i.e. 4 bits. (16 = 24)<br>40 × 4 = 160.</p></blockquote><p>因爲我們用字元呈現，那麼每個字元是4-bit，我們就可以推算以字串的表示方式的長度爲 2^160 = 16^40，也就是需要四十個十六進位值來表示。</p><p>這邊也有另外一個<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY0NDE5MzEvc2hhMS1lbmNvZGluZy10by1oZXgtaGFzLTQwLWNoYXJhY3RlcnMtYW5kLTE2MC1iaXRz">解答<i class="fa fa-external-link-alt"></i></span></p><blockquote><p>160 bits / 8 = 20 bytes; a byte in hex is 2 characters (<code>00</code> to <code>FF</code>) and 2 * 20 = 40 hex characters.<br>The longer output is the hexadecimally encoded version of the hexadecimal encoded hash.</p></blockquote><p>最後，我們看看空字串的SHA-1雜湊值，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA-1(<span class="string">&quot;&quot;</span>) = da39a3ee5e6b4b0d3255bfef95601890afd80709</span><br></pre></td></tr></table></figure><p>想不到吧，空字串也可以有雜湊值。</p><h5 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h5><hr><p>我們來看看維基百科怎麼描述SHA-2：</p><blockquote><p>SHA-2，名稱來自於安全雜湊演算法2（英語：Secure Hash Algorithm 2）的縮寫，一種密碼雜湊函式演算法標準，由美國國家安全局研發，由美國國家標準與技術研究院（NIST）在2001年發布。屬於SHA演算法之一，是SHA-1的後繼者。其下又可再分為六個不同的演算法標準，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</p></blockquote><p>由上面這段，我們可以知道SHA-2使用更多參數來提高混合性，進而誕生SHA-224、SHA-256等等雜湊算法。</p><p>以SHA-256爲例子來說，它的256我們可以由SHA-1猜測到32 * 8 = 256。</p><p>也就是它擁有八個32-bit暫存器， 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h0 := 0x6a09e667</span><br><span class="line">h1 := 0xbb67ae85</span><br><span class="line">h2 := 0x3c6ef372</span><br><span class="line">h3 := 0xa54ff53a</span><br><span class="line">h4 := 0x510e527f</span><br><span class="line">h5 := 0x9b05688c</span><br><span class="line">h6 := 0x1f83d9ab</span><br><span class="line">h7 := 0x5be0cd19</span><br></pre></td></tr></table></figure><p>它最後會產生256-bit的摘要長度資料。</p><p>算法跟SHA-1相比，也是大同小異，可以直接參照<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU0hBLTIjJUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1">維基百科<i class="fa fa-external-link-alt"></i></span>。</p><p>最後有個問題，不管是SHA-1還是SHA-2，我們說暫存器是32-bit，但是暫存器初始值爲什麼卻有八個十六進位值？</p><p>因爲我們用八個十六進位值去表示八個字元長度的字串，也就是一個字元是4-bit，那就是8 * 4 = 32 bits。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><hr><p>我們從對稱與非對稱的加密演算法瞭解可以保障PKI中敘述的資料傳遞的隱密性，也從不同演算法瞭解安全的意義。</p><p>雜湊演算法則是因爲低碰撞性的原因，讓我們可以檢查傳遞資料的完整性。</p><p>但是PKI中的四大特性，還有身份鑑別與不可否認性還沒提到，這就要等到下次的簽驗章再來解說。</p><h2 id="尾語"><a href="#尾語" class="headerlink" title="尾語"></a>尾語</h2><hr><p>其實自學這些內容還滿辛苦的，都是網路上拼拼湊湊的知識片段，還不見得每個都寫得一樣。</p><p>我到目前還沒找到一個寫得完整的書或是網站，包括我自己也覺得我寫得不太好。</p><p>如果有問題，歡迎留言討論。</p><p>如果是轉載的話，麻煩附上網址，謝謝 😊</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;接續上次的PKI，我們知道有件事是資安裏面一定會遇到的事！&lt;/p&gt;
&lt;p&gt;也就是大家的密碼絕對不會用明文呈現。&lt;/p&gt;
&lt;p&gt;那麼，我們要如何把一段明文變成密碼呢？&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="cryptograph" scheme="http://natlee.github.io/Blog/tags/cryptograph/"/>
    
    <category term="security" scheme="http://natlee.github.io/Blog/tags/security/"/>
    
    <category term="encrypt" scheme="http://natlee.github.io/Blog/tags/encrypt/"/>
    
    <category term="decrypt" scheme="http://natlee.github.io/Blog/tags/decrypt/"/>
    
  </entry>
  
  <entry>
    <title>資安常識(1) - 公鑰基礎建設（PKI）概念</title>
    <link href="http://natlee.github.io/Blog/posts/1123965036/"/>
    <id>http://natlee.github.io/Blog/posts/1123965036/</id>
    <published>2021-09-16T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>網路世界如何保障資訊安全，在資安的課本中常常會提到PKI</p><p>那麼，什麼是PKI？🤷‍♀️</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><h3 id="什麼是PKI？"><a href="#什麼是PKI？" class="headerlink" title="什麼是PKI？"></a>什麼是PKI？</h3><hr><p>PKI是英文<code>Public key infrastructure</code>的縮寫，中文名稱是<code>公鑰基礎建設</code>。</p><p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU5JTk2JThCJUU5JTg3JTkxJUU5JTkxJUIwJUU1JTlGJUJBJUU3JUE0JThFJUU1JUJCJUJBJUU4JUE4JUFE">維基百科<i class="fa fa-external-link-alt"></i></span>的說明</p><blockquote><p>PKI是一組由軟硬體、參與者、管理政策與流程組成的基礎架構，其目的在於創造、管理、分配、使用及儲存憑證。</p></blockquote><p>那麼，這個東西是幹嘛的？🤔</p><p>在資安中，有四個大特性是一定要嚴格遵守，這樣才能保證網路上的安全。</p><p>PKI就是前人經過各種考驗後，最後濃縮精簡出來的安全架構，而它就能夠來確保這四大特性。</p><p>所有定義都被放在製作網路安全程式時，必看的規格聖經<code>RFC</code>中。</p><p>那麼，四大特性分別是什麼？</p><ol><li><p>身份識別（Authentication）：確保資料傳送者與接收者的身分可以唯一被識別。</p><ul><li>舉例：沒有<code>身份識別</code>，每個人都可以僞造彼此的身份，如網路銀行來說，大家不用識別都可以去幫別人提款。</li></ul></li><li><p>隱密性（Confidentiality）：確保資料經過加密後無法被直接辨識。</p><ul><li>舉例：沒有<code>隱密性</code>的話，我們就可以直接辨讀機密資料，也就沒辦法避免密碼以明文方式外泄的狀況。</li></ul></li><li><p>完整性（Integrity）：確保資料在傳輸過程的完整與正確性，必須避免未授權的更改或僞造。</p><ul><li>舉例：沒有<code>完整性</code>的話，我們可以直接更改資料，如我們可以直接更改匯款金額。</li></ul></li><li><p>不可否認性（Non-Repudiation）：確保傳送者無法否認之前傳送過某訊息；相反，也可以防止接收的人否認曾經接收過訊息。</p><ul><li>舉例：沒有<code>不可否認性</code>的話，我們就可以在網路證券下單，然後在局勢不對的狀況改口跟券商說我剛剛其實沒做這筆交易。</li></ul></li></ol><p>也就是說，在網路上，這四大特性缺一不可，如果少一個都會出現每一項例子上的資安風險。</p><h3 id="PKI內的角色職責"><a href="#PKI內的角色職責" class="headerlink" title="PKI內的角色職責"></a>PKI內的角色職責</h3><hr><p>爲了維護剛剛說的四大特性，必須要有以下這些狠角色（狠是我隨便加的</p><ul><li><p><strong>認證機構（Certificate Authority, CA）</strong><br>  負責產生、發放、註銷、更新憑證的單位。</p></li><li><p><strong>註冊中心（Register Authority, RA）</strong><br>  負責證書註冊的審核單位。</p></li><li><p><strong>驗證中心（Validation Authority, VA）</strong><br>  確認驗章和憑證是否有效的單位。</p></li><li><p><strong>儲存庫（Directory Authority, DA）</strong><br>  存放目前發放憑證及已註銷憑證（CRL）的倉庫。</p></li><li><p><strong>信賴夥伴（Relying Party, RP）</strong><br>  信賴PKI架構的服務提供者。</p></li><li><p><strong>終端實體（End Entity, EE）</strong><br>  申請使用憑證的單位。</p></li></ul><p>看到這一定會有一堆問題，像我第一次看的時候，我就想說爲啥名稱這麼中二炫砲</p><p>然後這個解釋爲啥只是解釋字面的上意思，感覺沒什麼更深的含義</p><p>這樣想就錯了，太苦了，它們的含義可多了，但教科書不一定會跟你說</p><p>首先，我們先把可能會產生的疑問再分別列出來湊字數（不</p><ul><li><p><strong>認證機構（Certificate Authority, CA）</strong><br>  負責產生、發放、註銷、更新憑證的單位。</p><ul><li><p>什麼是憑證？<br>  <code>憑證</code>可以想成網路上用來識別個人身份的資料卡，上面會有個人資訊、個人的公鑰以及誰認可這張資料卡的證明（也就是簽章）。</p><p>  然後，這個說明可能會產生更多問題，像是什麼是公鑰、什麼是簽章或是爲什麼有人可以去認可別人的資料卡等等</p><p>  但是，遇到問題總要解決嘛</p><ul><li><p>公鑰<br>  密碼學上有個東西叫做加密，它確保了四大特性的其中一項 <code>隱密性</code>。<br>  一般來說，加密分爲<code>對稱</code>與<code>非對稱</code>兩種。<br>  在非對稱加密中，根據不同的算法生成鑰匙的時候，事前會產生兩把鑰匙，分別是公私鑰（有一個非常有名的加密方式叫做RSA加密算法）。那麼公鑰就可以想成是一把公開的鑰匙；私鑰則是只能自己擁有的鑰匙。</p><p>  其中，鑰匙成對的意思就是一把加密，我們可以用另一把解密。<br>  我如果用私鑰加密，對方能用我的公鑰解開的話，不就能證明是我是私鑰的唯一擁有者了嗎？這個就是底下簽章的概念。</p><p>  這邊可能又會有問題說，對稱我知道了，但什麼是對稱？公私鑰的定義又是什麼？問題先打住，這些內容，我在之後會針對<code>對稱加密</code>與<code>非對稱加密</code>說明。</p></li><li><p>簽章<br>  簽章就是指剛剛提到的，確保了四大特性的其中一項 <code>身份鑑別性</code>。<br>  我們拿私鑰去對文件加密就是簽章。</p><p>  但問題是爲什麼用私鑰，不用公鑰？因爲簽章就是要證明你認可這份文件，所以得拿<code>只有你有</code>的東西來證明，公鑰大家都可以用，私鑰只有你有，所以簽章用私鑰。<br>  再來，文件很長很肥很大，真的是這樣做嗎？<br>  又是那招，問題先打住，我在之後會有文章針對<code>簽驗章方法</code>再說明。</p></li><li><p>如何認可別人的資料卡<br>  這題答案也就是這個角色的定義，CA是頒發憑證的權威機構，所以他必須是<code>能夠被信任</code>的單位，如果一個能夠被信任的單位去認可你的資料卡，那就代表你的資料卡能夠被信任。<br>  那麼，如果我的資料卡被認可後，我又再認可別人會怎麼樣？這樣你就變成一種中介，形成一整個信任鏈。<br>  可是，信任的過程有這麼簡單嗎？當然沒有。<br>  舉例來說，今天有一個故事是這樣的</p><blockquote><p>你中午出門吃飯，找到一間小吃店，很自然的坐下來點了一碗陽春麵，並且等餐點來了之後，拿起旁邊的筷子直接開吃。吃完之後，拿出鈔票跟老闆結了帳，慢慢走出小吃店並且感受到陽光，今天真是樸實無華的一天。</p></blockquote><p>  我們來檢視一下這個故事，或許能看到一些信任的問題</p><ul><li>你爲什麼敢出門？有沒有可能一出門就被炸死？</li><li>爲什麼看到小吃店就敢走進去？</li><li>你怎麼相信椅子是安全的？</li><li>餐點來了怎麼敢吃？裏面沒被下毒嗎？</li><li>爲什麼你能相信旁邊的筷子沒有用過？</li><li>爲什麼鈔票能拿來用？</li></ul><p>  從這些問題我們就能看出來，其實這世界並沒有那麼可信</p><p>  像我之前就在蛋花湯裏面不小心吃到釘書針😥</p><p>  只是我們依然選擇相信，爲什麼呢？</p><p>  不是人很正向，充滿正能量，而是因爲經由很多事蹟或是證據來證明相對可信，我們就能夠選擇相信</p><p>  以把錢存到銀行來說的話，我們相信銀行能幫我們保管錢也是因爲除了政府認可外，從各種方面得知銀行的來頭不小以及受到銀行的行銷，甚至是街坊鄰居朋友們都推薦，我們才敢把錢放進銀行。</p><p>  讓我們回到原本的話題，認證機構就是這樣的一個存在，它們透過一些方法來證明自己相對可信並且廣爲人知（我是不知道是不是大家都認得每一間認證機構啦），因此能夠作爲頒發證書的一個單位。</p><p>  不過，講到憑證，有些人會突然想到<code>SSL憑證</code>，這又是另外一回事了。</p></li></ul></li><li><p>憑證怎麼產生、發放、註銷、更新？<br>  這個問題，我在底下<code>PKI運作流程</code>會提到。</p></li></ul></li><li><p><strong>註冊中心（Register Authority, RA）</strong><br>  負責證書註冊的審核單位。</p><ul><li><p>證書跟憑證一樣嗎？<br>  沒錯，兩個是一樣的，只是用語不同，但指的是同一個東西，都是Certificate。</p></li><li><p>審核是什麼意思？<br>  審核就是使用者想要申請憑證的時候，總該有個人出面來確認申請人的資訊是否有正確填寫，就是這樣的意思。</p></li></ul></li><li><p><strong>驗證中心（Validation Authority, VA）</strong><br>  確認驗章和憑證是否有效的單位。</p><ul><li><p>怎麼跑出驗章這種鬼東西？這三小？<br>  我在之後會有文章針對<code>簽驗章方法</code>再說明。</p></li><li><p>驗憑證要怎麼驗？<br>  剛剛有提到，憑證可以想成是一個可信任單位去認可你的資料卡。<br>  可是問題是說，認可是什麼？我要怎麼認可？難道我用個喇叭開廣跟世界頻道說我認可這張卡，就等於認可了嗎？<br>  認可的實際方法就是用<code>只有你有</code>的東西來去綁定，也就是能證明這東西是你認可的。<br>  那麼，我們剛剛有提到什麼東西是<code>只有你有</code>的嗎？<br>  對了，就是那個，那個，那個，<code>私鑰</code>！<br>  我用<code>私鑰</code>對資料卡進行加密，就代表我認可這個資料卡</p><p>  這時候就有新的問題，爲什麼加密可以代表我認可？</p><p>  這邊就扯到非對稱加密的精髓，也就是一把鑰匙加密，我們只能用另一把解密<br>  所以說，私鑰只有你有，你用只有你有的東西加密，那不就代表你認可了嗎？<br>  那我能夠用公鑰解密出<code>可被識別的資訊</code>（也就是解密成功），就代表這兩個鑰匙是一對的，也證明這是你認可的資訊了。</p></li></ul></li><li><p><strong>儲存庫（Directory Authority, DA）</strong><br>  存放目前發放憑證及已註銷憑證（CRL）的倉庫。</p><ul><li><p>憑證發很多張不會塞爆嗎？<br>  這邊該考慮的不是放很多張不會塞爆這樣的問題，而是目前流通的有效憑證，會不會導致倉庫存取的時候阻塞？這邊最後就會牽扯到存有大量資料的資料庫存取的問題，我們就不在此討論。<br>  那麼，每張憑證都有<code>有效期限</code>，每當這個期限過了之後，這張憑證就會失效，所以正常流通的<code>有效</code>憑證，也不會有很多張。</p></li><li><p>註銷憑證是怎樣？怎樣做才會被註銷？<br>  根據不同CA頒佈的憑證實務準則（CPS），裏面會寫道怎樣會被註銷。<br>  常見的原因會是違反當初約定使用的原則、法律因素、使用者覺得憑證有安全疑慮而提出註銷或是使用者不存在了（像是往生或是單位解散等等狀況）<br>  而成功註銷的話，CA也會在CRL中註明原因。</p></li></ul></li><li><p><strong>信賴夥伴（Relying Party, RP）</strong><br>  信賴PKI架構的服務提供者。</p><ul><li>信賴我是懂啦，畢竟要信任才會使用，可是服務提供者是怎麼回事？<br>  這邊我們可以舉例，像是證券商就是信賴夥伴，他們認爲並相信PKI架構能夠爲交易提供安全。那麼，券商再以PKI爲基礎提供證券戶來進行證券交易，這也就是提供者的身份了。</li></ul></li><li><p><strong>終端實體（End Entity, EE）</strong><br>  申請使用憑證的單位。</p><ul><li>剛剛有個提供者，這邊怎麼又申請了？這些角色是有病嗎？<br>  這個終端實體，名稱聽起來超級炫砲，但其實就是一般使用者，我們在上一個信賴夥伴有提到的證券戶就是一種終端實體，白話就是憑證的使用者。</li></ul></li></ul><p>從上面這些角色的基本介紹來看，我們可以知道這東西超級複雜，但也因爲如此才能保障我們網路上交易的安全。</p><h3 id="PKI運作流程"><a href="#PKI運作流程" class="headerlink" title="PKI運作流程"></a>PKI運作流程</h3><hr><p>這邊我們以PKI中的憑證申請跟憑證驗證來說</p><h4 id="憑證申請"><a href="#憑證申請" class="headerlink" title="憑證申請"></a>憑證申請</h4><hr><p>在憑證申請中，我們舉出一個實例來看</p><p>有一天，我們心血來潮想要辦個申請個證券線上交易用的憑證，要怎麼做？</p><p>首先，你必須要有證券戶，然而如何擁有證券戶呢？</p><p>常用管道爲臨櫃申請或線上申請</p><p>我們以臨櫃申請爲例子，這邊會出現的角色有<code>EE</code>、<code>RA</code>以及<code>CA</code></p><ol><li><strong>EE透過臨櫃與RA約定帳號與取得密碼單</strong><br> 通常臨櫃的時候，對方會查看你的雙證件，甚至拍照記錄你的身份，所以約定後，就等於達成信任關係。</li><li><strong>EE透過手機APP進行線上證券帳號的登入，並向RA送出憑證申請</strong><br> 等一下！等一下！怎麼直接送出憑證申請？<br> 這邊其實有更詳細的內容！<br> 手機的APP會幫你產生公私鑰對，並且把你的資訊及公鑰做成憑證申請請求（CSR）的格式送出給RA，那麼這個格式定義在RFC中的PKCS#10<br> 這邊就產生了一個問題，什麼是PKCS#10？<br> PKCS就是有一個公司叫RSA資訊安全公司（對！就是那個RSA），定義了網路上大家如何使用這些密碼跟資訊的標準，也就是公鑰密碼標準（Public Key Cryptography Standards）。可以想成是把這些接口做一個規格化以方便溝通的方法。<br> 那麼，什麼是#10？是編號嗎？能吃嗎？<br> 我們來看看維基百科的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUFDJUU5JTkyJUE1JUU1JUFGJTg2JUU3JUEwJTgxJUU1JUFEJUE2JUU2JUEwJTg3JUU1JTg3JTg2">公鑰密碼標準<i class="fa fa-external-link-alt"></i></span>頁面，上面有寫道 <blockquote><p>參見RFC 2986。規範了向憑證中心申請憑證之CSR（certificate signing request）的格式。</p></blockquote> 也就是說，這就是標準中編號十的內容，主要是定義CSR格式。<br> 除此之外，還有許多不同的編號分別定義了各種密碼標準在通訊上的格式。</li><li><strong>RA將資訊審核，通過後轉送給CA進行簽章變成憑證</strong><br> 這邊產生一個問題是，CA如何信任這個RA？<br> 一樣的程序再走一次，RA本身也需要跟CA申請憑證才能擔任RA這個角色。<br> 那麼，RA要怎麼申請這個擔任審核角色的憑證？<br> 根據不同CA有制定不同等級的方法去接受RA這個角色的憑證申請，但脫不了關係都是會去查驗申請RA身份的人是誰（有沒有這個人或公司，身份證或是相關的工商登記及詢問申請這個的用途等等）。<br> RA只要能夠用當初申請憑證時能對應到的私鑰去對這個申請進行簽章，然後CA驗章成功就代表這個RA是曾經申請過這個憑證並且是我CA能夠信任的RA。</li><li><strong>CA簽章完後，將憑證轉送回RA，再轉送回EE存放</strong></li></ol><p>經過這些步驟，一個憑證的申請過程就完成。</p><p>以上就是憑證的產生與發放過程，看起來很複雜，的確很複雜。</p><p>之前我都沒想過手機上按下一個按鈕，背後發生的事情這麼麻煩。</p><p>另外，剛剛有說到憑證註銷與更新</p><ul><li><p>憑證註銷<br>  通常都是因故被吊銷，有些例子是違反使用原則，就像是駕照被吊銷一樣。<br>  舉個例子來說，使用者EE覺得自己的私鑰有流出疑慮，決定申請憑證註銷，那麼會經過哪些流程呢？</p><ol><li><strong>EE臨櫃申請註銷或是透過線上申請（要永遠記得私鑰簽章可以代表自己認可）</strong></li><li><strong>RA審核資訊，確認沒有問題後轉送給CA</strong></li><li><strong>CA將註銷的憑證與原因更新到DA，並於下次CRL發佈時間公開</strong><br> CRL全名是憑證註銷清單（Certificate Revocation List），是一種黑名單的概念，上面出現的憑證都是被註銷導致失效的。這個清單由CA定時公告，VA會取得這份清單來驗憑證有效性。</li></ol></li><li><p>憑證更新<br>  憑證總是會失效，不外乎到期。但在到期前（通常是一個月前），RA會通知EE是否要更新憑證。<br>  那麼，憑證是如何被更新？</p><ol><li><strong>RA通知EE憑證快要到期</strong></li><li><strong>EE產生新的公私鑰對並向RA發出憑證更新請求</strong><br> 這邊要注意這個請求還是會使用舊的私鑰去簽章（不然RA不認識你）。</li><li><strong>RA收到請求後，審核通過將資訊轉送給CA簽章變成憑證</strong></li><li><strong>最後CA將憑證轉送RA再交給EE，憑證更新成功</strong></li></ol></li></ul><h4 id="憑證驗證"><a href="#憑證驗證" class="headerlink" title="憑證驗證"></a>憑證驗證</h4><hr><p>我們有憑證了！接下來呢？</p><p>憑證總是需要使用的，要如何用呢？</p><p>我們接着上面的例子，以網路下單的憑證使用爲例</p><p>這邊出現的角色有<code>EE</code>、<code>RP</code>、<code>VA</code>、<code>RA</code>及<code>CA</code>（哇靠這不是幾乎全員到齊）</p><ol><li><strong>EE使用憑證對交易資料產生簽章值</strong><br> 等等！簽章值？！怎麼突然又有新名詞！<br> 簡單來說，簽章值是就是用私鑰對雜湊值加密。<br> 那麼，雜湊（hash）是透過數學轉換跟運算產生一定長度的資料（產生的資料稱爲摘要，重複性很低，也就是低碰撞性），並且用私鑰加密代表的是我認可這段資料。<br> 整個意思就是，我用私鑰認可這個足以代表整筆交易的一定長度資料。<br> 從這邊，我們可以看出來雜湊值既然是一定長度的資料，又可以代表不同長度的資料（當初覺得跟UUID超像），不就可以確保<code>完整性</code>了嗎？ 既然完整性代表資料沒被修改過，又被私鑰加密，若能解密成功代表EE認可並同意本次交易內容。也就是本次交易沒辦法反悔或任意修改交易內容，以此也可以達成<code>不可否認性</code>。</li><li><strong>EE將交易資料、簽章值與憑證交給RP來進行交易</strong></li><li><strong>RP將剛剛收到的資訊轉交給VA來進行檢驗</strong></li><li><strong>VA檢驗簽章正確性</strong><br> 這邊會在之後的<code>簽驗章方法</code>進行說明。</li><li><strong>VA檢驗憑證有效性</strong><br> 憑證怎樣算有效？<br> 剛剛有提到，<code>在時間內</code>以及<code>不在註銷清單內</code>都算有效，可是問題來了！<br> 時間內還好說，憑證上就有寫，但是要如何知道不在註銷清單內？ 有兩種正規的方法可以知道憑證是否被註銷，一種是VA定期向CA取得CRL清單，另一種是直接線上向CA查詢憑證狀態，也就是OCSP（Online Certificate Status Protocol）。</li><li><strong>VA驗章驗證完成後，通知RP結果</strong></li><li><strong>RP根據結果決定是否提供EE服務</strong></li></ol><p>這邊我們一直都沒有提到<code>DA</code>這個角色，不是因爲它不重要，而是因爲它的概念純粹只是一個存放憑證的資料庫。</p><p>雖然PKI的角色互動中會常碰到<code>DA</code>，但在各個狠角色交互過程中就顯得沒那麼耀眼，所以我就不討論它了。</p><p>另外，有些問題剛剛可能沒有想過，就是它們分別是誰？</p><p>在驗證的時候，RP是券商、CA是CA、EE是證券戶（也就是使用者）。</p><p>RA根據申請憑證的時候，我們是向RA申請，所以可以猜到RA是券商！</p><p>那麼，VA是誰？</p><p>VA可以是券商，也可以是驗證服務的第三方提供者。</p><p>在實務上，它就僅僅只是個驗證程式，定期取得註銷清單，然後收各種驗證請求，吐出回傳值。</p><p>如果說，VA是券商的話，且我們剛剛知道RA是券商，那麼在驗證上，VA也可以透過旁門左道直接向RA詢問憑證狀態來節省時間。</p><p>以上，就是憑證使用的驗證流程，我覺得也是超複雜的。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><hr><p>我們可以從PKI的構成來得知它博大精深，而且觸角延伸到我們生活中使用網路的各個角落。</p><p>在看這些東西之前，我對它根本沒有瞭解。使用這些東西的時候，就跟水龍頭打開就有水一樣自然。</p><p>但是現在大概瞭解PKI是什麼，就像是瞭解水龍頭流出來水怎麼來。</p><p>希望這篇文章對剛入門的人有所幫助，看完的人都能夠略知一二。</p><h2 id="尾語"><a href="#尾語" class="headerlink" title="尾語"></a>尾語</h2><hr><p>最近工作上需要，所以不得不補完這方面相關知識，網路上有很多資訊過於專業，或是不太清楚。</p><p>我在查資料補完知識的時候也順便在這邊做個記錄，避免日後忘記。當然也一定會有疏漏或是不詳細的地方，如果有看到覺得有問題的地方，再請你留言通知我！</p><p>若需要轉載請註明網址，謝謝 😊</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;網路世界如何保障資訊安全，在資安的課本中常常會提到PKI&lt;/p&gt;
&lt;p&gt;那麼，什麼是PKI？🤷‍♀️&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="cryptograph" scheme="http://natlee.github.io/Blog/tags/cryptograph/"/>
    
    <category term="pki" scheme="http://natlee.github.io/Blog/tags/pki/"/>
    
    <category term="security" scheme="http://natlee.github.io/Blog/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Git 筆記</title>
    <link href="http://natlee.github.io/Blog/posts/4239708371/"/>
    <id>http://natlee.github.io/Blog/posts/4239708371/</id>
    <published>2021-09-06T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>Git 常用指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git branch -avv</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><h3 id="Pull-fetch-and-push"><a href="#Pull-fetch-and-push" class="headerlink" title="Pull, fetch and push"></a>Pull, fetch and push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git add .</span><br><span class="line">git commit -m &lt;COMMIT_MESSAGE&gt;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="Show-current-repository-status"><a href="#Show-current-repository-status" class="headerlink" title="Show current repository status"></a>Show current repository status</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>Sample Result (No changed files):</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with &#x27;origin/master&#x27;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working <span class="built_in">tree</span> clean </span><br></pre></td></tr></table></figure><p>Sample Result (With uncommitted changes)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with &#x27;origin/master&#x27;.</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git <span class="built_in">restore</span> &lt;file&gt;...&quot; to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"><span class="function">        modified:   <span class="title">source</span>/.<span class="title">obsidian</span>/<span class="title">workspace</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Untracked</span> <span class="title">files</span>:</span></span><br><span class="line"><span class="function">  (<span class="title">use</span> &quot;<span class="title">git</span> <span class="title">add</span> &lt;<span class="title">file</span>&gt;...&quot; <span class="title">to</span> <span class="title">include</span> <span class="title">in</span> <span class="title">what</span> <span class="title">will</span> <span class="title">be</span> <span class="title">committed</span>)</span></span><br><span class="line"><span class="function">        <span class="title">source</span>/<span class="title">_posts</span>/20210907-<span class="title">git</span>-<span class="title">cheat</span>-<span class="title">table.md</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">no</span> <span class="title">changes</span> <span class="title">added</span> <span class="title">to</span> <span class="title">commit</span> (<span class="title">use</span> &quot;<span class="title">git</span> <span class="title">add</span>&quot; <span class="title">and</span>/<span class="title">or</span> &quot;<span class="title">git</span> <span class="title">commit</span> -<span class="title">a</span>&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="Show-all-branch-with-upstream"><a href="#Show-all-branch-with-upstream" class="headerlink" title="Show all branch with upstream"></a>Show all branch with upstream</h3><p>Using command with following.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git branch -avv</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">Sample Result</span><br><span class="line"></span><br><span class="line">```cmd</span><br><span class="line">* master                                                            944c6b6 [origin/master] Update</span><br><span class="line">  remotes/origin/HEAD                                               -&gt; origin/master</span><br><span class="line">  remotes/origin/dependabot/npm_and_yarn/hexo-renderer-marked-4.1.0 33e72a0 Bump hexo-renderer-marked from 4.0.0 to 4.1.0</span><br><span class="line">  remotes/origin/gh-pages                                           a0c1163 Deploy NatLee/Blog to github.com/NatLee/Blog.git:gh-pages</span><br><span class="line">  remotes/origin/master                                             944c6b6 Update</span><br></pre></td></tr></table></figure><p>The branch of result</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* master            <span class="number">944</span>c6b6    [origin/master]   Update</span><br><span class="line">    ↑                  ↑             ↑             ↑</span><br><span class="line">Current branch      Revision      Upstream       Commit message</span><br></pre></td></tr></table></figure><p><code>Upstream branches</code> are local branches that have a direct relationship to a remote branch.</p><h3 id="Show-remote-informations"><a href="#Show-remote-informations" class="headerlink" title="Show remote informations"></a>Show remote informations</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><p>Sample result:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/NatLee/Blog.git</span><br><span class="line">  Push  URL: https://github.com/NatLee/Blog.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dependabot/npm_and_yarn/hexo-renderer-marked-<span class="number">4</span>.<span class="number">1</span>.<span class="number">0</span> tracked</span><br><span class="line">    gh-pages                                           tracked</span><br><span class="line">    master                                             tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;Git 常用指令&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -avv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote show origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/tags/develop/"/>
    
    <category term="git" scheme="http://natlee.github.io/Blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用Container來快速建立開發環境(以python為例)</title>
    <link href="http://natlee.github.io/Blog/posts/440569875/"/>
    <id>http://natlee.github.io/Blog/posts/440569875/</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p><img src="https://www.docker.com/sites/default/files/d8/2019-07/horizontal-logo-monochromatic-white.png" alt="whale"></p><p>一次開發一次爽<br>一直開發一直慘<br>解決環境問題的一種好方法 ── Docker</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><h3 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h3><p>一開始先在 VScode Plugin 中找到並安裝 Remote Container 插件</p><p><img src="https://i.imgur.com/jGE3rXY.png" alt="Remote container plugin"></p><p>然後，找一個你喜歡的地方，clone官方範例</p><p><code>git clone https://github.com/Microsoft/vscode-remote-try-python</code></p><p> 使用 VScode 打開它，VScode抓到設定檔後，右下角會跳出訊息問你要不要使用Container開啟，請按下<strong>Reopen in Container</strong>!</p><p><img src="https://i.imgur.com/Ibkv1g5.png" alt="Reopen in container"></p><p>等待建立完成後，你會發現整個環境都在Cotainer內了，舒服！<br>接著注意左邊檔案可以發現一個資料夾**.devcontainer**<br>這是VScode建立容器參照的設定</p><p><img src="https://i.imgur.com/ZxSGfeo.png" alt=".devcontainer"></p><p>點進去 <strong>devcontainer.json</strong> 可以看到有一行拿來指定port<br>這邊可以自行設定要publish到外部的port<br>換句話說就是你要使用的port<br>預設9000，但為了示範整個流程跟衝port，所以我這邊把它改成4000<br>其他還有一些執行相關的有趣設定可以研究 </p><p><img src="https://i.imgur.com/gOwm6zg.png" alt="port"></p><p>接著由於 VScode 設定的關係<br>我們要去 <strong>.vscode</strong> 資料夾內查看他的設定<br>可以發現我們直接F5在VScode內偵錯時，他執行port不是我們剛剛指定的4000也因為這樣我們必須把20行改成4000</p><blockquote><p>這邊有一些原因，是因爲上一步驟指定4000後，如果VScode沒有在這邊設定指定4000並且跑過一次，他會暫時鎖住4000 port 會造成 connection refuse，算是一個坑，但如果你沒有port相沖的問題，基本上開發用預設的9000測試就可以了</p></blockquote><p><img src="https://i.imgur.com/rsvco2q.png" alt="setting"></p><p>接著，儲存後按下 F5 執行 <strong>app.py</strong>! </p><p><img src="https://i.imgur.com/X6r1kma.png" alt="demo page"></p><h3 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h3><p>有時候總是會有那麼點原因導致你可能不想用vscode設定<br>而是想要直接在Container用單純的command去執行</p><p>那麼只要map好輸出的port也可以在底下的terminal直接run</p><p><code>python app.py</code></p><p><img src="https://i.imgur.com/J3SGDOj.png"></p><p><img src="https://i.imgur.com/c9XBSDH.png"></p><p>或是直接用 docker 進入container內 run </p><p><img src="https://i.imgur.com/MxmZLIb.png"></p><p>這邊就要說兩種做法了，你可以直接 <strong>docker exec -it</strong> 進去（這樣做的話，你得知道他幫你建立的容器叫什麼，可能要先 <strong>docker ps -a</strong> 一下） 也可以透過現在新版 docker 提供的 dashboard 進去</p><p><img src="https://i.imgur.com/B0RyI5Z.png"><br><img src="https://i.imgur.com/KyeUmAg.png">  </p><p>進去之後，再 cd 到 <strong>/workspaces/vscode-remote-try-python</strong> ，就可以看到你的程式了，其中 <strong>vscode-remote-try-python</strong> 是你的專案名稱</p><p>如果你程式有更動的話，像是我新增了一個套件<br>你可以選擇直接在容器內使用pip 安裝，也可以rebuild Container(建議) 來更新環境（當然，新的套件要註明在requirements.txt內）</p><p>簡單來說就是左下角點下去，上面會出現一個bar，按下第二個重新建立container （他會幫你蓋掉舊的Container，舒服！)</p><p><img src="https://i.imgur.com/I7OyA5a.png"><br><img src="https://i.imgur.com/Oy6au5Z.png"></p><p>如果我們直接關掉VScode 他也會幫你把container關閉</p><p><img src="https://i.imgur.com/iPFmnXf.png"></p><p>下次再打開專案資料夾時，他就會問你要不要從container開啟，如果開啟的話，他就會幫你把container打開</p><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>透過container開發真的很方便，麻煩的環境不用每次都顧慮<br>不過這樣做，整體步驟還是有點冗長，希望之後能夠發現更快部署的方法</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vYS9HblFFUHBp">這次用到的截圖imgur存放區<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://www.docker.com/sites/default/files/d8/2019-07/horizontal-logo-monochromatic-white.png&quot; alt=&quot;whale&quot;&gt;&lt;/p&gt;
&lt;p&gt;一次開發一次爽&lt;br&gt;一直開發一直慘&lt;br&gt;解決環境問題的一種好方法 ── Docker&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="python" scheme="http://natlee.github.io/Blog/tags/python/"/>
    
    <category term="docker" scheme="http://natlee.github.io/Blog/tags/docker/"/>
    
    <category term="container" scheme="http://natlee.github.io/Blog/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>Blog Upgraded</title>
    <link href="http://natlee.github.io/Blog/posts/1950864450/"/>
    <id>http://natlee.github.io/Blog/posts/1950864450/</id>
    <published>2021-07-22T04:20:05.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>上一次更新竟然是兩年前<br>來說說最近的修改好了</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><p>最近因爲工作告一段落的關係</p><p>突然想到我竟然有部落格，而且好久沒更新了</p><p>所以我就翻修一下，順便看看以前寫的文章</p><p>發現有些很中二，也有些文章可以回味當初的無奈</p><p>這次的改修主要是以下幾個</p><ul><li>更新<code>Hexo</code></li><li>更新主題<code>Next</code>並切換成dark mode</li><li>將留言換成Github的issue</li><li>修了一下以前一些文章的typing format</li><li>拿掉右下角吉祥物(反正也沒人看就拿掉了)</li></ul><p>這些更改除了增刪修改以前文章外</p><p>畢竟等於是砍掉重裝，所以都不怎麼花時間</p><p>我在修改文章的時候發現，我剛開這個blog的那個時間點</p><p>似乎對於git及markdown格式不怎麼熟悉，單純一個衝動就開了</p><p>現在應該任何一篇google找到的hexo教學文應該都比我一開始寫的來得詳細吧 🤔</p><p>雖然以現在來說，我在工具的使用比當初熟練，但相對的對很多東西的熱情也被磨去一半</p><p>可能這就是年紀增加，看事情的角度也不同的結果 😥</p><p>之後，還是會不定期更新 😊😊😊</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;上一次更新竟然是兩年前&lt;br&gt;來說說最近的修改好了&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/categories/blog/"/>
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Python中的多執行緒(multithread)及多程序(multiprocessing)</title>
    <link href="http://natlee.github.io/Blog/posts/4162982688/"/>
    <id>http://natlee.github.io/Blog/posts/4162982688/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/7w9laRD.jpg"></p><center>*ソードアート・オンライン*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>在很多時候，我們想要加快程式的速度時，除了花錢買更好的硬體外，也會考慮將手邊重複的工作進行平行處理</p><p>在Python中，平行處理的方式已經被包裝成特定模組</p><p>但是，多執行緒(multithread)與多程序(multiprocessing)還是有所不同</p><span id="more"></span><h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><hr><p>理論上，以前學過的作業系統中對於執行緒(thread)與程序(process)各有解釋</p><h3 id="執行緒-Thread"><a href="#執行緒-Thread" class="headerlink" title="執行緒(Thread)"></a>執行緒(Thread)</h3><ul><li><p>同一顆CPU執行</p></li><li><p>所有執行緒共享記憶體</p></li><li><p>一個執行緒被中斷會導致集體死亡</p></li></ul><h3 id="程序-Process"><a href="#程序-Process" class="headerlink" title="程序(Process)"></a>程序(Process)</h3><ul><li><p>每個程序擁有整份程式碼</p></li><li><p>各個程序有獨立的記憶體空間</p></li><li><p>可以多顆CPU運行</p></li></ul><p>在Python中，這邊比較需要注意到的問題是CPU。</p><p>Python本身對於執行緒排程進行優化，所以並不可完全適用理論上的結果。</p><p>假設今天我們有一函數<code>job</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = x * x</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="string">&#x27;zero&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> x%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="string">&#x27;even&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">&#x27;odd&#x27;</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我們執行下面函數來得到單一thread單一process的baseline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runBaseLine</span>():</span></span><br><span class="line">    starttime = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        job(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Baseline took &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(time.time() - starttime))</span><br></pre></td></tr></table></figure><p>它的執行結果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Baseline took 50.02211403846741 seconds</span><br></pre></td></tr></table></figure><p>這個程式花了50秒的時間來完成</p><p>接下來，我們要進行多執行緒與多程序的結果比較</p><h3 id="比較結果"><a href="#比較結果" class="headerlink" title="比較結果"></a>比較結果</h3><p><img src="http://i.imgur.com/wbFo504.png"></p><center>*ソードアート・オンライン*</center><ul><li><strong>Multithread</strong></li></ul><p>我們以下程式使用多執行緒來執行任務</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runMultithread</span>():</span></span><br><span class="line">    threads = <span class="built_in">list</span>()</span><br><span class="line">    starttime = time.time()</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        threads.append(threading.Thread(target=job, args=(element,)))</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:    </span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Multithread took &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(time.time() - starttime))</span><br></pre></td></tr></table></figure><p>多執行緒的結果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multithread took 5.0071680545806885 seconds</span><br></pre></td></tr></table></figure><ul><li><strong>Multiprocessing</strong></li></ul><p>我們以下程式使用多程序來執行任務</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runMultiprocessing</span>():</span></span><br><span class="line">    starttime = time.time()</span><br><span class="line">    processes = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=job, args=(i,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Multiprocessing took &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(time.time() - starttime))</span><br></pre></td></tr></table></figure><p>多程序的結果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiprocessing took 5.031498193740845 seconds</span><br></pre></td></tr></table></figure><ul><li><strong>Multiprocessing using pool</strong></li></ul><p>我們以下程式使用池(pool)來分配多程序來執行任務</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runMultiprocessingUsingPool</span>():</span></span><br><span class="line">    test = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">    starttime = time.time()</span><br><span class="line">    <span class="keyword">with</span> multiprocessing.Pool() <span class="keyword">as</span> p:</span><br><span class="line">        p.<span class="built_in">map</span>(job, test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Multiprocessing using pool took &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(time.time() - starttime))</span><br></pre></td></tr></table></figure><p>分配方法的結果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiprocessing using pool took 15.129114151000977 seconds</span><br></pre></td></tr></table></figure><p>我們把結果統整成表格</p><table><thead><tr><th></th><th>Baseline</th><th>Multithread</th><th>Multiprocessing</th><th>Multiprocessing using pool</th></tr></thead><tbody><tr><td>Time(s)</td><td>50.022</td><td>5.007</td><td>5.031</td><td>15.129</td></tr></tbody></table><p>由表格中，我們可以發現在Python中多執行緒不一定是只使用單顆CPU執行，因為多程序與多執行緒結果差不多</p><p>但令人意外的是使用pool來分配的多程序執行相比一般多程序卻會花較多時間</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B1cmJhbl9pbnN0aXR1dGUvdXNpbmctbXVsdGlwcm9jZXNzaW5nLXRvLW1ha2UtcHl0aG9uLWNvZGUtZmFzdGVyLTIzZWE1ZWY5OTZiYQ==">Using Multiprocessing to Make Python Code Faster<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/7w9laRD.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*ソードアート・オンライン*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在很多時候，我們想要加快程式的速度時，除了花錢買更好的硬體外，也會考慮將手邊重複的工作進行平行處理&lt;/p&gt;
&lt;p&gt;在Python中，平行處理的方式已經被包裝成特定模組&lt;/p&gt;
&lt;p&gt;但是，多執行緒(multithread)與多程序(multiprocessing)還是有所不同&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="python" scheme="http://natlee.github.io/Blog/tags/python/"/>
    
    <category term="develop" scheme="http://natlee.github.io/Blog/tags/develop/"/>
    
    <category term="multithread" scheme="http://natlee.github.io/Blog/tags/multithread/"/>
    
    <category term="multiprocessing" scheme="http://natlee.github.io/Blog/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>Python中List的Copy反直覺踩坑</title>
    <link href="http://natlee.github.io/Blog/posts/165930856/"/>
    <id>http://natlee.github.io/Blog/posts/165930856/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/7mrHp3H.jpg"></p><center>*佐賀偶像是傳奇*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>你以為的以為，跟我以為的以為<br>坑！都是坑！滿滿的坑！</p><span id="more"></span><h2 id="掰個例子"><a href="#掰個例子" class="headerlink" title="掰個例子"></a>掰個例子</h2><hr><p>身為一個肥宅在Python中處理資料是常見的事</p><p>舉個簡單土砲的 <code>.csv</code> 檔讀取例子（本文皆使用Python3.6， <code>.csv</code> 檔為逗號分隔）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csvLoader</span>(<span class="params">csvPath:<span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; load csv to list format data &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Windows系統用Excel存的 .csv 大部分都是 Big5 格式，柳暗花明又一坑 : (</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(csvPath, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csv:</span><br><span class="line">        parseList = <span class="built_in">list</span>() <span class="comment"># store all data</span></span><br><span class="line">        columnNames = csv.readline().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>:] <span class="comment"># load column names in first row and ignore first column which is id</span></span><br><span class="line"></span><br><span class="line">        rowData = <span class="built_in">dict</span>() <span class="comment"># use rowData to store all data in .csv file</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> csv.readlines():</span><br><span class="line">            raw = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># here split by &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i, columnName <span class="keyword">in</span> <span class="built_in">enumerate</span>(columnNames):</span><br><span class="line">                rowData[columnName] = raw[i+<span class="number">1</span>] <span class="comment"># cause we ignore first column, so we need &#x27;+1&#x27;.</span></span><br><span class="line">            parseList.append(rowData)</span><br><span class="line">    <span class="keyword">return</span> parseList</span><br></pre></td></tr></table></figure><p>各位觀眾看看上面的 code，看起來似乎…..沒有問題？</p><h2 id="夜路走多踩到坑"><a href="#夜路走多踩到坑" class="headerlink" title="夜路走多踩到坑"></a>夜路走多踩到坑</h2><hr><p>如何分辯程式執行是否有問題<br>不如我們直接拿個 .csv 檔丟進去做讀檔測試</p><p>以下是我們今天測試檔案 test.csv 的格式</p><table><thead><tr><th align="center"></th><th>name</th><th>sex</th><th>phone</th><th>birthday</th></tr></thead><tbody><tr><td align="center">1</td><td>Honoka</td><td>female</td><td>0912345678</td><td>8/3</td></tr><tr><td align="center">2</td><td>Chika</td><td>female</td><td>8765432190</td><td>8/1</td></tr><tr><td align="center">3</td><td>Ereka</td><td>none</td><td>0000000000</td><td>1/1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>csvLoader(<span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ereka&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>: <span class="string">&#x27;0000000000&#x27;</span>, <span class="string">&#x27;birthday&#x27;</span>: <span class="string">&#x27;1月1日&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ereka&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>: <span class="string">&#x27;0000000000&#x27;</span>, <span class="string">&#x27;birthday&#x27;</span>: <span class="string">&#x27;1月1日&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ereka&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;phone&#x27;</span>: <span class="string">&#x27;0000000000&#x27;</span>, <span class="string">&#x27;birthday&#x27;</span>: <span class="string">&#x27;1月1日&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>太神奇了傑克，竟然全部都是 Ereka ！</p><p>所以問題到底出在哪…?</p><h2 id="以為的以為"><a href="#以為的以為" class="headerlink" title="以為的以為"></a>以為的以為</h2><hr><p>假設這世界上只有兩個人，一個是 a ，另一個是它的複製人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> ]</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>這時， b 等於 [1, 2, 3]</p><p>但今天我們把 a 進行擴充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>a 會變成 [1, 2, 3, 4]，而 b …</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>b 也變成 [1, 2, 3, 4] 了！<br>於是我們檢查一下它們的 id</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4340014344</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">4340014344</span></span><br></pre></td></tr></table></figure><p>賓果，id 一樣<br>但如果今天我們用 copy 的話…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>Wow！ c 成為全新的個體了！<br>我們檢查一下它的 id</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(c)</span><br><span class="line"><span class="number">4339725448</span></span><br></pre></td></tr></table></figure><p>4339725448 不等於 4340014344<br>果然是不同的東西了！</p><h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><hr><p>我說那個…</p><p>一開始的程式到底錯在哪呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseList = <span class="built_in">list</span>()</span><br><span class="line">rowData = <span class="built_in">dict</span>() <span class="comment"># use rowData to store all data in .csv file</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> csv.readlines():</span><br><span class="line">    raw = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># here split by &#x27;,&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, columnName <span class="keyword">in</span> <span class="built_in">enumerate</span>(columnNames):</span><br><span class="line">        rowData[columnName] = raw[i+<span class="number">1</span>] <span class="comment"># cause we ignore first column, so we need &#x27;+1&#x27;.</span></span><br><span class="line">    parseList.append(rowData)</span><br></pre></td></tr></table></figure><p>有看出來了嗎？<br>我們把它換成另外一個更簡單看清楚的程式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">list</span>()</span><br><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(rows):</span><br><span class="line">        a[i] = row</span><br><span class="line">    p.append(a)</span><br></pre></td></tr></table></figure><p>再…再更簡單一點</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">list</span>()</span><br><span class="line">a = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    a.append(i)</span><br><span class="line">    p.append(a)</span><br></pre></td></tr></table></figure><p>這樣子最終的輸出會如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>也就是說， p 這個List內所有元素的 id 都一樣<br>換句話說， p append的都是記憶體位置中同樣的List<br>所以才會產生這樣的結果</p><p>我們回到最一開始的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csvLoader</span>(<span class="params">csvPath:<span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; load csv to list format data &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Windows系統用Excel存的 .csv 大部分都是 Big5 格式，柳暗花明又一坑 : (</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(csvPath, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csv:</span><br><span class="line">        parseList = <span class="built_in">list</span>() <span class="comment"># store all data</span></span><br><span class="line">        columnNames = csv.readline().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>:] <span class="comment"># load column names in first row and ignore first column which is id</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> csv.readlines():</span><br><span class="line">            rowData = <span class="built_in">dict</span>() <span class="comment"># use rowData to store all data in .csv file</span></span><br><span class="line">            raw = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># here split by &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i, columnName <span class="keyword">in</span> <span class="built_in">enumerate</span>(columnNames):</span><br><span class="line">                rowData[columnName] = raw[i+<span class="number">1</span>] <span class="comment"># cause we ignore first column, so we need &#x27;+1&#x27;.</span></span><br><span class="line">            parseList.append(rowData)</span><br><span class="line">    <span class="keyword">return</span> parseList</span><br></pre></td></tr></table></figure><p>我們把 rowData 放進 for 迴圈內，每次都重新建立一個全新的 dict<br>當然， id 也不同</p><p>parseList append的 rowData id 都不一樣<br>最後也就不會大家都長一樣了</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><hr><p>感恩讚嘆God Alice &lt;(_ _)&gt;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/7mrHp3H.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*佐賀偶像是傳奇*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;你以為的以為，跟我以為的以為&lt;br&gt;坑！都是坑！滿滿的坑！&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="code" scheme="http://natlee.github.io/Blog/tags/code/"/>
    
    <category term="python" scheme="http://natlee.github.io/Blog/tags/python/"/>
    
    <category term="develop" scheme="http://natlee.github.io/Blog/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>解決SynologyNAS上Gitlab發生的502錯誤</title>
    <link href="http://natlee.github.io/Blog/posts/3672378701/"/>
    <id>http://natlee.github.io/Blog/posts/3672378701/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/F87nc59.jpg"></p><center>*OVERLORD*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今天我家跳電了<br>於是NAS就重啟了</p><span id="more"></span><h2 id="似乎出了點問題"><a href="#似乎出了點問題" class="headerlink" title="似乎出了點問題"></a>似乎出了點問題</h2><hr><p>回家後，我打開NAS檢查有沒有錯誤<br>發現它自帶的一致性檢查通過，不愧是鍍金的紅標硬碟，十分可靠</p><p>但我打開Gitlab的頁面確認時，出現一個致命的錯誤 :/</p><p>Oh!</p><p><img src="https://i.imgur.com/eVL3B7d.jpg"></p><p>502，居然是502<br>怎麼會這樣</p><p>於是我重啟兩次Gitlab服務，依然502<br>看來效果並不超群</p><p>那麼就只好到docker裡面看看了</p><p><img src="https://i.imgur.com/97XYNKI.png"></p><p>太慘了吧<br>而且還是unicorn</p><iframe width="560" height="315" src="https://www.youtube.com/embed/YPtVSuy_wuU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>你才unicorn，你全家都unicorn :(</p><p>後來只好向Google大神求救<br>於是發現原來是unicorn不斷地呼叫已死去的同胞</p><p>不斷跌倒，不斷站起<br>真是一個勵志的故事，而且造就不凡的CPU使用量</p><p>但我們還是得解決這個問題<br>只好進入Gitlab的docker container終端<br>毫不留情的砍掉犧牲者的PID名單</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@synology_gitlab:/home/git/gitlab<span class="comment"># rm /home/git/gitlab/tmp/pids/unicorn.pid</span></span><br></pre></td></tr></table></figure><p>此時，重啟Gitlab服務，等個幾分鐘<br>天空又如同以往一樣清澈</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><hr><p>我後來去看Gitlab的container日誌發現一句話</p><p><img src="https://i.imgur.com/MrnVKll.png"></p><p>我想大概是停電造成關閉不完全以致殘留檔案造成後來復電重啟時開檔錯誤吧 :’(</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnN0ZWFkLmlkLmF1LzIwMTcvMDMvc3lub2xvZ3ktZ2l0bGFiLWVycm9yLTUwMi5odG1s">Synology GitLab error 502<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/F87nc59.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*OVERLORD*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;今天我家跳電了&lt;br&gt;於是NAS就重啟了&lt;/p&gt;</summary>
    
    
    
    <category term="gitlab" scheme="http://natlee.github.io/Blog/categories/gitlab/"/>
    
    
    <category term="synology" scheme="http://natlee.github.io/Blog/tags/synology/"/>
    
    <category term="nas" scheme="http://natlee.github.io/Blog/tags/nas/"/>
    
    <category term="gitlab" scheme="http://natlee.github.io/Blog/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>使用Django框架建置圖片上傳與展示的平台</title>
    <link href="http://natlee.github.io/Blog/posts/2800319203/"/>
    <id>http://natlee.github.io/Blog/posts/2800319203/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/PECvJrh.jpg"></p><center>*ネトゲの嫁は女の子じゃないと思った？*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今天一張UR都沒抽到<br>所以在這邊整理了一個如何製作Django建置圖片上傳平台教學</p><span id="more"></span><h2 id="準備材料"><a href="#準備材料" class="headerlink" title="準備材料"></a>準備材料</h2><hr><p>我使用的Python版本是3.6.5，以及Django版本是2.0.6<br>處理圖片可能需要使用到pillow套件，資料庫則要用到mysqlclinent<br>可以在命令列中輸入以下指令安裝需要的套件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install Django==2.0.6</span><br><span class="line">pip install pillow</span><br><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure><p>避免過程中找不到資料夾位置<br>我把完成整個流程後的資料結構先放在這邊</p><pre><code>testsite│   db.sqlite3│   manage.py├─  imgTest│  │   admin.py│  │   apps.py│  │   models.py│  │   tests.py│  │   views.py│  │   __init__.py│  └─  migrations│       │   __init__.py│       └─  0001_initial.py├─  media│  └─  img│       └─  XXXXX.jpg├─  templates│  │   imgUpload.html│  └─  showImg.html└─  testsite    │   settings.py    │   urls.py    │   wsgi.py    └─  __init__.py</code></pre><h2 id="使用Django建立專案"><a href="#使用Django建立專案" class="headerlink" title="使用Django建立專案"></a>使用Django建立專案</h2><hr><ol><li><p> 首先，先在命令列中創建一個Django的專案，名為testsite。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject testsite</span><br></pre></td></tr></table></figure></li><li><p> 再移動到專案資料夾內，建立一個app。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> testsite</span><br><span class="line">python manage.py startapp imgTest</span><br></pre></td></tr></table></figure></li><li><p>(1)  進到testsite/testsite內，找到settings.py，並在install app的列表中最後一項新增剛建立的app。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    INSTALLED_APPS = (</span><br><span class="line">        <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;imgTest&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> (2)  然後修改settings.py檔，在上面新增mysql的資訊、圖片上傳的路徑資訊。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;media&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">MEDIA_URL = <span class="string">&#x27;/media/&#x27;</span></span><br></pre></td></tr></table></figure><p> (3) 在修改settings.py檔中，TEMPLATES的路徑資訊，其中的DIRS項增加一個templates。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [<span class="string">&#x27;templates&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p> 進到剛建立的app資料夾testsite/imgTest中，並修改models.py檔，新增以下class。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMG</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># upload_to為圖片上傳的路徑，不存在就創建一個新的。</span></span><br><span class="line">    img_url = models.ImageField(upload_to=<span class="string">&#x27;img&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p> 在命令列中，執行下列指令以連結類別與資料庫的關係。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li><li><p> 進到app資料夾testsite/imgTest中，並於views.py檔新增上傳圖片及顯示圖片的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上傳圖片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uploadImg</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        img = IMG(img_url=request.FILES.get(<span class="string">&#x27;img&#x27;</span>))</span><br><span class="line">        img.save()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;imgupload.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示圖片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showImg</span>(<span class="params">request</span>):</span></span><br><span class="line">    imgs = IMG.objects.<span class="built_in">all</span>()</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;imgs&#x27;</span> : imgs</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;showImg.html&#x27;</span>, context)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p> 再進到testsite/testsite中，修改urls.py檔案，並新增Html template及載入圖片的對應路徑，如下。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span> static</span><br><span class="line"><span class="keyword">from</span> imgTest.views <span class="keyword">import</span> uploadImg, showImg</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls), <span class="comment"># admin</span></span><br><span class="line">    path(<span class="string">&#x27;uploadImg/&#x27;</span>, uploadImg), <span class="comment"># 上傳圖片的地方</span></span><br><span class="line">    path(<span class="string">&#x27;showImg/&#x27;</span>, showImg) <span class="comment"># 顯示圖片的地方</span></span><br><span class="line">] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure></li><li><p> 直接在專案資料夾testsite/底下建立templates資料夾，並在裡面新增上傳及展示網頁的模板。</p></li></ol><ul><li>imgUpload.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;img&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>showImg.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示圖片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for item in imgs %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; item.img_url.url &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>在命令列中，於專案資料夾底下輸入以下指令便可執行Django的伺服器。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure> 此時出現下列文字時，便可以進到網頁中進行圖片上傳與觀看了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Django version 2.0.6, using settings <span class="string">&#x27;testsite.settings&#x27;</span></span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br></pre></td></tr></table></figure></li></ol><h2 id="實際展示"><a href="#實際展示" class="headerlink" title="實際展示"></a>實際展示</h2><hr><ul><li>上傳圖片<blockquote><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL3VwbG9hZEltZy8=">http://localhost:8000/uploadImg/<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ul><p>先到上傳圖片的頁面，按下選擇檔案挑好圖片並按送出。<br><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Django_Upload_and_Show_Image/01.png"></p><p>因為是簡易頁面，所以在上傳成功時，畫面中並不會有任何提示。</p><p>這時，你會看到命令列出現下列資訊。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[20/Jun/2018 06:38:52] <span class="string">&quot;GET /uploadImg/ HTTP/1.1&quot;</span> 200 422</span><br><span class="line">Not Found: /favicon.ico</span><br><span class="line">[20/Jun/2018 06:38:53] <span class="string">&quot;GET /favicon.ico HTTP/1.1&quot;</span> 404 2319</span><br><span class="line">[20/Jun/2018 06:39:37] <span class="string">&quot;POST /uploadImg/ HTTP/1.1&quot;</span> 200 422</span><br></pre></td></tr></table></figure><p>意思是一開始進去網頁載入頁面，然後找不到favicon的icon圖片<br>最後一行則返回200，代表圖片已經POST成功。</p><ul><li>顯示圖片<blockquote><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL3Nob3dJbWcv">http://localhost:8000/showImg/<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ul><p>再到展示的頁面就可以看到剛剛上傳的照片了。<br><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Django_Upload_and_Show_Image/02.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[20/Jun/2018 06:40:04] <span class="string">&quot;GET /showImg/ HTTP/1.1&quot;</span> 200 344</span><br><span class="line">[20/Jun/2018 06:40:04] <span class="string">&quot;GET /media/img/riko.jpg HTTP/1.1&quot;</span> 200 65002</span><br></pre></td></tr></table></figure><p>在命令列可以看到返回200代表載入頁面並下載圖片成功。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><hr><p>因為網路上Django跟Python的版本不一<br>除了Python版本造成不相容外<br>Django版本也有很大的影響<br>所以很多地方相關的範例都有些小錯誤，沒辦法執行<br>希望在這邊做成一篇完整且能執行的版本後能夠幫助到大家<br>順便記錄一下，以後自己忘記也能提醒自己如何操作</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><hr><p>[<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NfYmVhdXRpZnVsL2FydGljbGUvZGV0YWlscy83OTc1NTM2OA==">django 实现图片上传和显示操作<i class="fa fa-external-link-alt"></i></span>]<br>[<span class="exturl" data-url="aHR0cHM6Ly9oay5zYW93ZW4uY29tL2EvMDI1NzA2YmYwMzRiZDgzMzU5YmZmZTE5MGFiNmNmNWZjNjIzOThhNjdiYzA1ODliNDU1MmI2ZTMzYjE2NWMzNA==">Django上傳並顯示圖片<i class="fa fa-external-link-alt"></i></span>]</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/PECvJrh.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*ネトゲの嫁は女の子じゃないと思った？*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;今天一張UR都沒抽到&lt;br&gt;所以在這邊整理了一個如何製作Django建置圖片上傳平台教學&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="django" scheme="http://natlee.github.io/Blog/tags/django/"/>
    
    <category term="python" scheme="http://natlee.github.io/Blog/tags/python/"/>
    
    <category term="web" scheme="http://natlee.github.io/Blog/tags/web/"/>
    
    <category term="platform" scheme="http://natlee.github.io/Blog/tags/platform/"/>
    
  </entry>
  
  <entry>
    <title>以 Google 表單做資料庫使用方法</title>
    <link href="http://natlee.github.io/Blog/posts/3924355189/"/>
    <id>http://natlee.github.io/Blog/posts/3924355189/</id>
    <published>2017-06-07T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/CHxfjRG.jpg" alt="我很感動"></p><center>*劍風傳奇*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>之前研究了一陣子，做出了點東西。</p><p>但記憶不佳怕忘記，還是記錄一下，順便幫助別人。</p><p>內容大概是用 Google 表單來當資料庫就可以做點事。（<em>這句不是跟標題一樣嗎？</em>）</p><span id="more"></span><h2 id="新增表單與-EntryID"><a href="#新增表單與-EntryID" class="headerlink" title="新增表單與 EntryID"></a>新增表單與 EntryID</h2><hr><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/01.png" alt="01"></p><p>首先，先建立新的表單，並填好表格名稱及各種問題，題目的名字在爬蟲時會用到，故可取簡單點，像這邊取<em>store_data_base</em> 及<em>store_data_base_user</em></p><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/02.png" alt="02"></p><p>按回覆，再按綠綠的，可以建立google表格（<em>建議跟名字相同，怕你像我一樣容易失憶搞混</em>），先建等等用。</p><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/03.png" alt="03"></p><p>按下傳送，會看到你的表單網址。Go！到你的表單去！</p><ol><li><p>按下F12，找到你欄位的ID，大概會長這樣 <code>entry.888061137</code></p></li><li><p>如有兩個(含)以上欄位可繼續，像我找到第二個是 <code>entry.662791979</code></p></li></ol><h2 id="表格探險"><a href="#表格探險" class="headerlink" title="表格探險"></a>表格探險</h2><hr><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/04.png" alt="04"></p><p>再來進到你的google表格（可從google雲端或一開始編輯表單回覆按下綠綠的進去）</p><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/05.png" alt="05"></p><p>按下 <em>檔案</em> ，再按下 <em>發佈到網路</em> ，會看到這般光景</p><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/06.png" alt="06"></p><p>勇敢按下 <em>發佈</em> ，會取得你的表格在網路上的位址，簡稱「<em>網址</em>」</p><h2 id="取得-JSON"><a href="#取得-JSON" class="headerlink" title="取得 JSON"></a>取得 JSON</h2><hr><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/07.png" alt="07"></p><p>放大一看，有沒有一串像是這樣的東西（<em>聽說它叫google spreadsheet key</em>）</p><p>※ 注意，新版Google表單在這邊會看到的是 <em>…/d/e/…</em> ，但我們要的是 *…/d/&lt;這才是我們要的&gt;*，那麼瀏覽器最上方網址列的網址就是我們要的。 2020-01-10</p><blockquote><p><code>1cyaKtRh8o-Ngq63KWSkPTKOr_nf2ZhN0TTzTVrqpKZI</code></p></blockquote><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/08.png" alt="08"></p><p>接著我們要串接一個網址：</p><blockquote><p><code>https://spreadsheets.google.com/feeds/worksheets/這邊放你剛剛拿到的一串東西/private/full</code></p></blockquote><p>我串出來長這樣，但一定跟你不一樣：</p><blockquote><p><code>https://spreadsheets.google.com/feeds/worksheets/1cyaKtRh8o-Ngq63KWSkPTKOr_nf2ZhN0TTzTVrqpKZI/private/full</code></p></blockquote><p>在瀏覽器輸入這串網址進入後，用 Ctrl + F 搜尋 <code>&lt;id&gt;</code> 這個Tag，於是你會發現有個 <code>&lt;/id&gt;</code> 前面有一段字非常潮，我這邊的潮字如下：</p><blockquote><p><code>ouce9z</code></p></blockquote><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/09.png" alt="09"></p><p>把剛剛的潮字接到一個網址中，格式如下：</p><blockquote><p><code>https://spreadsheets.google.com/feeds/list/這邊放google表格的那串/潮字/public/full?alt=json</code></p></blockquote><p>我接出來大概像下面這樣，你一定跟我不一樣：</p><blockquote><p><code>https://spreadsheets.google.com/feeds/list/1cyaKtRh8o-Ngq63KWSkPTKOr_nf2ZhN0TTzTVrqpKZI/ouce9zs/public/full?alt=json</code></p></blockquote><p>哇！太棒了！你就可以進到這個網頁了！於是你可以使用其他程式語言開始爬蟲！</p><h2 id="利用網址-Input-新增資料"><a href="#利用網址-Input-新增資料" class="headerlink" title="利用網址 Input 新增資料"></a>利用網址 Input 新增資料</h2><hr><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/10.png" alt="10"></p><p>這樣就結束？還沒！回到你的表單，並填好資料按送出！</p><p>送出後看看神奇的網址，太酷啦！</p><p>觀察一下會發現，<em>真是擅常送出表單的朋友呢！</em></p><p>在 <em>formResponse</em> 後面加上「?」再加上你的欄位 ID （<em>也就是一開始找的 Entry ID，如有兩個(含)以上請用&amp;連接</em>），就會得到以下網址：</p><blockquote><p><code>https://docs.google.com/forms/d/e/你剛剛網址中的formResponse前那串字/formResponse?你的EntryID=你的答案&amp;你的EntryID=你的答案</code></p></blockquote><blockquote><p><strong><font color="red">※ 避免此表單被新增故不直接貼完整網址請見諒</font></strong></p></blockquote><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/11.png" alt="11"></p><p>測試一下輸入 <em>你的答案</em> 在網址上並按回車鍵！回車！也就是Enter。</p><blockquote><p>「什…什麼！騙人的吧！」</p><p>「我____都拿出來了，你給我看這個？」</p><p>「你什麼時候產生了我對你使用鏡花水月的錯覺？」</p></blockquote><p>對的，網站還是同一頁。</p><p>這真是非常的感傷，直到你心灰意冷，請打開google表格。</p><p><img src="https://raw.githubusercontent.com/NatLee/BlogSource/master/Image/Google_Spreadsheet_Database/12.png" alt="12"></p><p>わ―い！すご―い！這真是驚人的大發現。</p><p>於是你就可以利用 google表單 來進行「<em>這樣還有那樣</em>」的事了！</p><hr><p>對了，在最後 <em>工商服務</em>  一下</p><p>新的 Line貼圖 上架了，覺得喜歡的可以幫忙支持一下</p><p><span class="exturl" data-url="aHR0cHM6Ly9zdG9yZS5saW5lLm1lL3N0aWNrZXJzaG9wL3Byb2R1Y3QvMTQ0NjI4Ng==">顏肥與夥伴們<i class="fa fa-external-link-alt"></i></span></p><p>謝謝大家！</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><hr><p>[<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ1MzEzNTEvcmV0cmlldmUtZ29vZ2xlLXNwcmVhZHNoZWV0LXdvcmtzaGVldC1qc29u">Retrieve Google Spreadsheet Worksheet JSON<i class="fa fa-external-link-alt"></i></span>]</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CHxfjRG.jpg&quot; alt=&quot;我很感動&quot;&gt;&lt;/p&gt;
&lt;center&gt;*劍風傳奇*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;之前研究了一陣子，做出了點東西。&lt;/p&gt;
&lt;p&gt;但記憶不佳怕忘記，還是記錄一下，順便幫助別人。&lt;/p&gt;
&lt;p&gt;內容大概是用 Google 表單來當資料庫就可以做點事。（&lt;em&gt;這句不是跟標題一樣嗎？&lt;/em&gt;）&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/categories/blog/"/>
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/tags/blog/"/>
    
    <category term="google" scheme="http://natlee.github.io/Blog/tags/google/"/>
    
    <category term="database" scheme="http://natlee.github.io/Blog/tags/database/"/>
    
    <category term="googlesheet" scheme="http://natlee.github.io/Blog/tags/googlesheet/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV學習筆記－RGB轉HSV</title>
    <link href="http://natlee.github.io/Blog/posts/3478006693/"/>
    <id>http://natlee.github.io/Blog/posts/3478006693/</id>
    <published>2016-04-17T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/HdGGqIw.jpg"></p><center>*最弱無敗機龍*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>RGB轉HSV，並分離成單通道R/G/B與H/S/V</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><p>首先，先回憶上次開圖的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">IplImage* img = <span class="built_in">cvLoadImage</span>(<span class="string">&quot;test.png&quot;</span>, <span class="number">1</span>); <span class="comment">//1表示三通道</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;test&quot;</span>,WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;test&quot;</span>, img);</span><br><span class="line"><span class="built_in">cvWaitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下來在其中加入兩行程式碼</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以img的大小製作一個空白的空間</span></span><br><span class="line">IplImage* hsv = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//把img從RGB轉成HSV</span></span><br><span class="line"><span class="built_in">cvCvtColor</span>(img, hsv, CV_BGR2HSV);</span><br></pre></td></tr></table></figure><blockquote><p><strong>cvCreateImage(size,depth,channels)</strong><br><strong>size</strong>代表圖像大小<br><strong>depth</strong>為圖像元素的位深度,<strong>IPL_DEPTH_8U</strong>或<strong>8</strong>代表無符號8位整型<br><strong>channels</strong>代表圖像通道數量</p></blockquote><p>這樣就成功以內建函式的方式轉換了原圖</p><p><img src="http://i.imgur.com/l6lihNQ.png"></p><p>詳細轉換的方式可參考OpenCV文件<br><span class="exturl" data-url="aHR0cDovL2RvY3Mub3BlbmN2Lm9yZy8yLjQvbW9kdWxlcy9pbWdwcm9jL2RvYy9taXNjZWxsYW5lb3VzX3RyYW5zZm9ybWF0aW9ucy5odG1sP2hpZ2hsaWdodD1jdnRjb2xvciNjdnRjb2xvcg==">點我到OpenCV<i class="fa fa-external-link-alt"></i></span></p><p>再來為了分離三個通道成R/G/B得先宣告存放空間並把img分離</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IplImage* Bimg=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">IplImage* Gimg=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">IplImage* Rimg=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cvSplit</span>(img, Bimg, Gimg, Rimg, <span class="number">0</span>);<span class="comment">//複製各個通道到三個空間</span></span><br><span class="line"><span class="comment">//目標圖像必須與來源圖像在大小和資料型態上一樣</span></span><br><span class="line"><span class="comment">//輸入多通道，輸出為B，G，R單通道</span></span><br></pre></td></tr></table></figure><p>但這時要注意，圖片因為單通道所以還是<strong>灰階的</strong><br>要再宣告三個三通道的圖片空間</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IplImage* pImg1=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">3</span>);</span><br><span class="line">IplImage* pImg2=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">3</span>);</span><br><span class="line">IplImage* pImg3=<span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img),<span class="number">8</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>並且把空間初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cvSetZero</span>(pImg1);</span><br><span class="line"><span class="built_in">cvSetZero</span>(pImg2);</span><br><span class="line"><span class="built_in">cvSetZero</span>(pImg3);</span><br></pre></td></tr></table></figure><p>此時，把三個通道合成後可以得到一張完整的圖(R/G/B)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意順序是BGR</span></span><br><span class="line"><span class="built_in">cvMerge</span>(Bimg,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,pImg3);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>,Gimg,<span class="number">0</span>,<span class="number">0</span>,pImg2);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>,<span class="number">0</span>,Rimg,<span class="number">0</span>,pImg1);</span><br><span class="line"><span class="comment">//將三個通道合成</span></span><br><span class="line"><span class="comment">//輸入参數為B，G，R單通道，最後一個為輸出</span></span><br></pre></td></tr></table></figure><p>最後，開個視窗把圖片輸出就成了<br>注意這邊是輸出<strong>pImg1、pImg2、pImg3</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;B&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;B&quot;</span>, pImg3);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;G&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;G&quot;</span>, pImg2);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;R&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;R&quot;</span>, pImg1);</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/AiAn03X.png"></p><p>為了分離H/S/V，我們必須也做同樣的事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用一開始轉換好的HSV宣告三個單通道圖片空間</span></span><br><span class="line">IplImage* Himg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">IplImage* Simg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">IplImage* Vimg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//宣告三個三通道圖片空間</span></span><br><span class="line">IplImage* HSV1 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* HSV2 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* HSV3 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把hsv複製到三個空間</span></span><br><span class="line"><span class="built_in">cvSplit</span>(hsv, Vimg, Simg, Himg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把圖片空間初始化</span></span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV1);</span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV2);</span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把三個通道合成，注意順序是VSH</span></span><br><span class="line"><span class="built_in">cvMerge</span>(Vimg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, HSV3);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, Simg, <span class="number">0</span>, <span class="number">0</span>, HSV2);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, <span class="number">0</span>, Himg, <span class="number">0</span>, HSV1);</span><br></pre></td></tr></table></figure><p>輸出後，我們可以得到三張圖，分別是H/S/V</p><p><img src="http://i.imgur.com/e3458Z0.png"></p><p>試著一次把所有圖都輸出</p><p><img src="http://i.imgur.com/Mql1XuL.png"></p><p>整個程式的程式碼可以參考如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">IplImage* img = <span class="built_in">cvLoadImage</span>(<span class="string">&quot;test.png&quot;</span>, <span class="number">1</span>); <span class="comment">//1表示三通道</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以img的大小製作一個空白的空間</span></span><br><span class="line">IplImage* hsv = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//把img從RGB轉成HSV</span></span><br><span class="line"><span class="built_in">cvCvtColor</span>(img, hsv, CV_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//轉R/G/B單通道-----------------------</span></span><br><span class="line">IplImage* Bimg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">1</span>);<span class="comment">//B單通道灰階</span></span><br><span class="line">IplImage* Gimg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">1</span>);<span class="comment">//G單通道灰階</span></span><br><span class="line">IplImage* Rimg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">1</span>);<span class="comment">//R單通道灰階</span></span><br><span class="line"><span class="built_in">cvSplit</span>(img, Bimg, Gimg, Rimg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">IplImage* pImg1 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* pImg2 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* pImg3 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(img), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cvSetZero</span>(pImg1);</span><br><span class="line"><span class="built_in">cvSetZero</span>(pImg2);</span><br><span class="line"><span class="built_in">cvSetZero</span>(pImg3);</span><br><span class="line"><span class="built_in">cvMerge</span>(Bimg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pImg3);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, Gimg, <span class="number">0</span>, <span class="number">0</span>, pImg2);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, <span class="number">0</span>, Rimg, <span class="number">0</span>, pImg1);</span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//轉H/S/V單通道-----------------------</span></span><br><span class="line">IplImage* Himg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">IplImage* Simg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">IplImage* Vimg = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">IplImage* HSV1 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* HSV2 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">IplImage* HSV3 = <span class="built_in">cvCreateImage</span>(<span class="built_in">cvGetSize</span>(hsv), <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cvSplit</span>(hsv, Vimg, Simg, Himg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV1);</span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV2);</span><br><span class="line"><span class="built_in">cvSetZero</span>(HSV3);</span><br><span class="line"><span class="built_in">cvMerge</span>(Vimg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, HSV3);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, Simg, <span class="number">0</span>, <span class="number">0</span>, HSV2);</span><br><span class="line"><span class="built_in">cvMerge</span>(<span class="number">0</span>, <span class="number">0</span>, Himg, <span class="number">0</span>, HSV1);</span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cvNamedWindow</span>(<span class="string">&quot;HSV&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;HSV&quot;</span>, hsv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;H&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;H&quot;</span>, HSV1);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;S&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;S&quot;</span>, HSV2);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;V&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;V&quot;</span>, HSV3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cvNamedWindow</span>(<span class="string">&quot;RGB&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;RGB&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;R&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;R&quot;</span>, pImg1);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;G&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;G&quot;</span>, pImg2);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;B&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;B&quot;</span>, pImg3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cvWaitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9jZzIwMTBzdHVkaW8uY29tLzIwMTIvMTAvMDkvb3BlbmN2LSVFOCVCRCU4OSVFNiU4RiU5QiVFOCU4OSVCMiVFNSVCRCVBOSVFNyVBOSVCQSVFOSU5NiU5My10cmFuc2Zvcm0tY29sb3Itc3BhY2Uv">[OpenCV] 轉換色彩空間 (Transform Color Space)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2ZhbmxpNy5uZXQvYS9iaWFuY2hlbmd5dXlhbi9DX18vMjAxNDA1MDIvNDk4MjY2Lmh0bWw=">基於Opencv下RGB圖像轉HSV，並分離成單通道R/G/B與H/S/V<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HdGGqIw.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*最弱無敗機龍*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;RGB轉HSV，並分離成單通道R/G/B與H/S/V&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="code" scheme="http://natlee.github.io/Blog/tags/code/"/>
    
    <category term="opencv" scheme="http://natlee.github.io/Blog/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV學習筆記－安裝與開圖</title>
    <link href="http://natlee.github.io/Blog/posts/3012259224/"/>
    <id>http://natlee.github.io/Blog/posts/3012259224/</id>
    <published>2016-04-16T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/aEGYK6p.jpg"></p><center>*少年女僕*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>OpenCV的安裝與環境設置</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><p>一開始先到OpenCV官網下載安裝<br><span class="exturl" data-url="aHR0cDovL29wZW5jdi5vcmcv">點我到OpenCV官網<i class="fa fa-external-link-alt"></i></span><br>通常都安裝在C槽中，安裝完後到系統設定環境變數</p><pre><code>C:\OpenCV3.1\build\x64\vc12\binC:\OpenCV3.1\build</code></pre><p>設定完後，重開機開啟VS2013<br>開新專案後，到右邊找到<strong>屬性管理員</strong><br>對<strong>Debug | Win32</strong>按右鍵<strong>新增新的專案屬性工作表</strong><br>接下來對它按右鍵<strong>屬性</strong>並找到<strong>VC++目錄</strong>的<strong>Include目錄</strong>並編輯它<br><img src="http://i.imgur.com/BIkxMqv.png"><br>接著看到<strong>程式庫目錄</strong>，一樣編輯它<br><img src="http://i.imgur.com/h5vWUaF.png"><br>再來看左邊清單找到<strong>連結器</strong><br><img src="http://i.imgur.com/xnnYSBz.png"><br>點擊它，再點<strong>輸入</strong>後一樣編輯<strong>其他相依性</strong><br><img src="http://i.imgur.com/zP70e7h.png"><br>這樣就完成專案的設定了<br>然後來寫第一個OpenCV的程式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/highgui/highgui.hpp&quot;</span><span class="comment">//引入OpenCV的功能</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;<span class="comment">//使用cv名稱</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">IplImage* img = <span class="built_in">cvLoadImage</span>(<span class="string">&quot;test.jpg&quot;</span>);<span class="comment">//宣告一個圖片資源</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;test&quot;</span>);<span class="comment">//命名視窗</span></span><br><span class="line"><span class="built_in">cvShowImage</span>(<span class="string">&quot;test&quot;</span>, img);<span class="comment">//以命名的視窗開起圖片</span></span><br><span class="line"><span class="built_in">cvWaitKey</span>(<span class="number">0</span>);<span class="comment">//等待</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://i.imgur.com/S6SHo7W.png"></p><p>當然用Mat的方式也可以開圖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>, CV_LOAD_IMAGE_COLOR);</span><br></pre></td></tr></table></figure><p>但是秀圖的方式要改成<strong>imshow</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">namedWindow</span>( <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>( <span class="string">&quot;test&quot;</span>, image );</span><br></pre></td></tr></table></figure><p>而IplImage與Mat的格式也能互轉</p><p><strong>IplImage -&gt; Mat</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IplImage* img = <span class="built_in">cvLoadImage</span>(<span class="string">&quot;test.jpg&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="function">Mat <span class="title">img2</span><span class="params">(img)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Mat -&gt; IplImage</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>, <span class="number">1</span>); <span class="comment">//用Mat型別讀取圖片;</span></span><br><span class="line">IplImage* img2;  <span class="comment">//宣告IplImage的變數</span></span><br><span class="line">img2=&amp;<span class="built_in">IplImage</span>(img) ; <span class="comment">//把Mat位置傳給img2</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ194aWFuNTIxL2FydGljbGUvZGV0YWlscy82ODk0MjI4">OpenCV学习笔记（一）——安装配置、第一个程序<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ194aWFuNTIxL2FydGljbGUvZGV0YWlscy82ODk0NzE2">OpenCV学习笔记（三）——Mat，图像的新容器<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/aEGYK6p.jpg&quot;&gt;&lt;/p&gt;
&lt;center&gt;*少年女僕*&lt;/center&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;OpenCV的安裝與環境設置&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://natlee.github.io/Blog/categories/study/"/>
    
    
    <category term="code" scheme="http://natlee.github.io/Blog/tags/code/"/>
    
    <category term="opencv" scheme="http://natlee.github.io/Blog/tags/opencv/"/>
    
    <category term="c++" scheme="http://natlee.github.io/Blog/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>修改Windows的登入密碼</title>
    <link href="http://natlee.github.io/Blog/posts/3382314989/"/>
    <id>http://natlee.github.io/Blog/posts/3382314989/</id>
    <published>2016-01-30T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/S6qH6xo.jpg" alt="更重要的是努力的話總會有回報的"></p><center>*紅殼的潘朵拉*</center><p>努力的話，真的就有回報嗎？</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>常常有人忘記密碼或電腦被鎖(?)，然後就會上網找攻略。<br>不過大部份攻略又是外文，這邊就做個小整理。</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><p><font color="red"><strong>※點擊圖片可以放大</strong></font></p><h3 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h3><hr><p><font color="blue"><strong>圖形化界面的置換修改法</strong></font></p><ol><li>插入<strong>Windows7</strong>安裝光碟</li><li>進入安裝畫面後，按下<strong>下一步</strong>再按<strong>修復您的電腦</strong></li><li>按下<strong>載入驅動程式</strong><br><img src="http://i.imgur.com/HBGt2Df.png"></li><li>進到<code>windows\system32</code>目錄底下</li><li>把<code>Magnify.exe</code>改名成<code>Magnify1.exe</code><br><img src="http://i.imgur.com/4nk5LR3.png"></li><li>把<code>cmd.exe</code>改名成<code>Magnify.exe</code><br><img src="http://i.imgur.com/YQQRNz5.png"><br><img src="http://i.imgur.com/ZC8gFsL.png"></li><li>重新啟動電腦</li><li>進入登入畫面按左下角協助工具選擇<strong>放大鏡</strong><br><img src="http://i.imgur.com/j5JlQCC.png"></li><li>輸入<code>net user 你的帳戶 123</code>後按Enter把密碼改成<strong>123</strong><br><img src="http://i.imgur.com/M7R14C3.png"></li><li>重新啟動進到光碟裡把<strong>放大鏡跟cmd</strong>改回原本名字</li></ol><p><font color="blue"><strong>指令置換修改法</strong></font></p><ol><li>插入<strong>Windows7</strong>安裝光碟</li><li>進入安裝畫面後，按下<strong>Shift+F10</strong></li><li>輸入<code>cd\</code>後按Enter跳至系統槽（可能C或D）</li><li>輸入<code>cd windows\system32</code>後按Enter跳到目錄底下</li><li>輸入<code>ren Magnify.exe Magnify1.exe</code>後按Enter把放大鏡改名</li><li>輸入<code>ren cmd.exe Magnify.exe</code>後按Enter把cmd改成放大鏡</li><li>關閉Command Window後重新啟動電腦</li><li>進入登入畫面按左下角協助工具選擇<strong>放大鏡</strong></li><li>輸入<code>net user 你的帳戶 123</code>後按Enter把密碼改成<strong>123</strong></li><li>輸入<code>cd\</code>後按Enter跳至系統槽（可能C或D）</li><li>重新啟動進到光碟後按下<strong>Shift+F10</strong></li><li>輸入<code>cd windows\system32</code>後按Enter跳到目錄底下</li><li>輸入<code>ren Magnify.exe cmd.exe</code>後按Enter把cmd改回來</li><li>輸入<code>ren Magnify1.exe Magnify.exe</code>後按Enter把放大鏡改回來</li><li>重新啟動電腦即完成，密碼為<strong>123</strong></li></ol><p>精隨其實就是把放大鏡跟CMD互換<br>所以任何一個作業系統安裝光碟都可以修改密碼<br><img src="http://i.imgur.com/jDFxVac.jpg" alt="當時我們不知道未來有多殘酷的試煉"></p><center>*房東妹子青春期*</center><h3 id="Windows-8-8-1-10"><a href="#Windows-8-8-1-10" class="headerlink" title="Windows 8/8.1/10"></a>Windows 8/8.1/10</h3><hr><p>Windows8/8.1/10的方法都一樣，所以直接放在一起。</p><p><font color="blue"><strong>指令置換修改法</strong></font></p><ol><li><p>插入<strong>Windows10</strong>安裝光碟<br><img src="http://i.imgur.com/oAoqGMO.png"></p></li><li><p>進入安裝畫面後，按下<strong>Shift+F10</strong><br><img src="http://i.imgur.com/Sa2Nrj8.png"></p></li><li><p>輸入以下指令後按Enter把<strong>utilman.exe</strong>改名加尾綴**.bak**<br><code>move d:\windows\system32\utilman.exe d:\windows\system32\utilman.exe.bak</code></p></li><li><p>輸入以下指令後按Enter把<strong>cmd.exe</strong>改名成<strong>utilman.exe</strong><br><code>copy d:\windows\system32\cmd.exe d:\windows\system32\utilman.exe</code><br><img src="http://i.imgur.com/gwGOzrs.png"></p><blockquote><p>圖中前兩次找不到路徑是system32少打32<br>第三次找不到是因為系統槽在<strong>D槽</strong><br>所以這邊要注意有沒有錯字</p></blockquote></li><li><p>關閉Command Window後重新啟動電腦</p></li><li><p>進入登入畫面按<strong>協助工具</strong>（左下角或右下角）</p></li><li><p>輸入<code>net user 你的帳戶 123</code>後按Enter把密碼改成<strong>123</strong><br><img src="http://i.imgur.com/HJ5MYM4.png"></p></li><li><p>重新啟動進到光碟後按下<strong>Shift+F10</strong></p></li><li><p>依序輸入以下指令把檔案換回來<br><code>move d:\windows\system32\utilman.exe d:\windows\system32\cmd.exe</code><br><code>move d:\windows\system32\utilman.exe.bak d:\windows\system32\utilman.exe</code></p></li><li><p>重新啟動電腦即完成，密碼為<strong>123</strong></p></li></ol><p>這邊要注意一下，這個方法僅限系統管理員Account非Microsoft帳號<br>如果你的系統管理員身份是M$帳號的話<br>請在<strong>第七步</strong>時把指令改成<code>net user 你要新增的帳戶 /add</code><br>這樣就可以進到有管理權限的帳戶來改掉原本進不去的帳戶密碼了</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><hr><p><img src="http://i.imgur.com/dfSNJi6.jpg" alt="我從來都沒想過這點"></p><center>*房東妹子青春期*</center><p>Win10換完檔案後，其實可以用輸入<code>wpeutil reboot</code>重啟<br><img src="http://i.imgur.com/tukE2wl.png"></p><p>不過改密碼的方法一樣都是<strong>置換法</strong>，總之能開cmd的話萬事都OK。<br>感謝收看</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly80c3lzb3BzLmNvbS9hcmNoaXZlcy9yZXNldC1hLXdpbmRvd3MtMTAtcGFzc3dvcmQv">Reset a Windows 10 password<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/S6qH6xo.jpg&quot; alt=&quot;更重要的是努力的話總會有回報的&quot;&gt;&lt;/p&gt;
&lt;center&gt;*紅殼的潘朵拉*&lt;/center&gt;

&lt;p&gt;努力的話，真的就有回報嗎？&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;常常有人忘記密碼或電腦被鎖(?)，然後就會上網找攻略。&lt;br&gt;不過大部份攻略又是外文，這邊就做個小整理。&lt;/p&gt;</summary>
    
    
    
    <category term="windows" scheme="http://natlee.github.io/Blog/categories/windows/"/>
    
    
    <category term="windows" scheme="http://natlee.github.io/Blog/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Blog近代化改修</title>
    <link href="http://natlee.github.io/Blog/posts/3907118332/"/>
    <id>http://natlee.github.io/Blog/posts/3907118332/</id>
    <published>2016-01-27T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/x3aK407.jpg" alt="何等鬼畜的行為"></p><center>*為美好的世界獻上祝福*</center><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>趁還有一點點時間來清裡長滿蜘蛛網的Blog。<br>然後加一些功能，順便記錄一下以免以後忘記。</p><span id="more"></span><h2 id="近代化改修"><a href="#近代化改修" class="headerlink" title="近代化改修"></a>近代化改修</h2><hr><h3 id="增加右下多功能鍵"><a href="#增加右下多功能鍵" class="headerlink" title="增加右下多功能鍵"></a>增加右下多功能鍵</h3><blockquote><p><strong><font color="red">※ 此篇是基於nexT主題的改修</font></strong></p></blockquote><p>首先抓住<strong>藏在themes/next/layout底下的小傢伙</strong></p><blockquote><p>_layout.swig</p></blockquote><p>摸了一下發現這玩意掌管整個Blog的布局<br>幾乎每個頁面都靠它插html進去</p><p>然後找到footer裡面跟原生theme界面很要好的那個置頂功能物件<br>先把原本的功能註解掉</p><pre><code>&lt;!--&lt;div class=&quot;back-to-top&quot;&gt;&lt;/div&gt;--&gt;</code></pre><p>接下來把我們要的東西加上去</p><pre><code>&lt;div id=&#39;ukagaka_panel&#39;&gt;&lt;/div&gt;</code></pre><p>不過這樣還不夠，再來找到body底端把重要的心臟<strong>css跟javascript</strong>放上去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&#x27;http://code.jquery.com/ui/jquery-ui-git.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/Blog/css/ukagaka/ukagaka.css&quot;&gt;</span><br><span class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/Blog/css/ukagaka/simpleFontawesome.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;/Blog/js/ukagaka/jquery.morris.ukagaka.resource.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;/Blog/js/ukagaka/typed.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  $(&#x27;#ukagaka_panel&#x27;).ukagaka();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>這邊不放jquery是因為<strong>venders.swig</strong>裡面已經有了<br><code>jquery_lazyload/jquery.lazyload.js?v=1.9.7</code><br>如果放了版本不相容會造成方法衝突</p></blockquote><p>最後把上面所需的js跟css放到網頁底下就大功告成了</p><hr><h3 id="增加404頁面"><a href="#增加404頁面" class="headerlink" title="增加404頁面"></a>增加404頁面</h3><blockquote><p>不過實用度高嗎？</p></blockquote><p><img src="http://i.imgur.com/QAnIoWi.jpg" alt="這問題有回答的必要嗎"></p><center>*夢幻之星2*</center><blockquote><p>首先直接在站點的source下新增一個<strong>404.html</strong><br>首先直接在站點的source下新增一個<strong>404.html</strong><br>首先直接在站點的source下新增一個<strong>404.html</strong></p></blockquote><p>這很重要，一定要講三次<br>再按照自己所需去修改css跟在網站底下放置所需的檔案<br>似乎這樣就完成了</p><p>我Github的Blog不是在帳號的最上層網域<br>所以一開始卡在不知道404頁面要放在哪裡</p><blockquote><p>Create a new HTML file named <code>404.html</code>—or a new Markdown file named <code>404.md</code>, with <code>permalink: /404.html</code> in its YAML front matter— at the root level of your GitHub Pages repository.</p><footer><strong>Github</strong><cite><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvY3VzdG9tLTQwNC1wYWdlcy8=">Custom 404 Pages<i class="fa fa-external-link-alt"></i></span></cite></footer></blockquote><p>看了官方文件也沒看懂哪個方法才要在root level上面<br>然後查了網上也滿多人說要在root level才能自己建404</p><p><img src="http://i.imgur.com/fGXnfga.jpg" alt="別給我滿嘴開火車"></p><center>*夢幻之星2*</center><p>原本準備要放棄洗洗睡，但不知為何又燃起一種再試試看的決心<br>試了一段時間發現，果然真的要講三次<br>真的只要在站點的source下新增一個<strong>404.html</strong>就行了</p><p><a href="http://natlee.github.io/ERROR">首頁的404</a><br><a href="http://natlee.github.io/Blog/ERROR">Blog的404</a></p><p>終於弄完才發現這個404的功用好像也只有現在打打文章可以用到<br>一般瀏覽Blog的時候也不會特別發生或去點到404…<br>但還是補充一下，雖然都是直接加<strong>404.html</strong><br>Hexo的404會自動嵌到Blog的網頁框框內<br>我覺得這樣的確是還滿不錯的</p><p><img src="http://i.imgur.com/66iLHqa.jpg" alt="這裡也有一個麻煩的傢伙啊"></p><center>*為美好的世界獻上祝福*</center><hr><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>最後，這邊推荐兩個不錯又實用的網站</p><p><span class="exturl" data-url="aHR0cDovL2h0bWw1dXAubmV0Lw==">Html5up<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy53aWJpYmkuY29tLw==">Wibibi<i class="fa fa-external-link-alt"></i></span></p><p>第一個裡面有現成的HTML5素材可以拿來參考或使用<br>第二個裡面有很多CSS的範例也是可以拿來參考或使用</p><p>總之Blog更新先到這邊<br>以後有時間再來研究一下</p><p>對了，覺得404畫面的人物滿可愛的話(?)<br>可以這邊請</p><p><span class="exturl" data-url="aHR0cDovL2xpbmUubWUvUy9zdGlja2VyLzEyMjY5Mzg=">Line貼圖 - Lovely Blond Hair Girl<i class="fa fa-external-link-alt"></i></span></p><p>謝謝大家，祝 <strong>新年快樂</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/x3aK407.jpg&quot; alt=&quot;何等鬼畜的行為&quot;&gt;&lt;/p&gt;
&lt;center&gt;*為美好的世界獻上祝福*&lt;/center&gt;


&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;趁還有一點點時間來清裡長滿蜘蛛網的Blog。&lt;br&gt;然後加一些功能，順便記錄一下以免以後忘記。&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/categories/blog/"/>
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Matlab 取代語法</title>
    <link href="http://natlee.github.io/Blog/posts/419938887/"/>
    <id>http://natlee.github.io/Blog/posts/419938887/</id>
    <published>2015-12-22T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>一直忘記，記錄一下。</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><p>把矩陣A中<strong>NaN</strong>的值取代為<strong>0</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(isnan(A)==<span class="number">1</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>把矩陣A中<strong>0</strong>的值取代為<strong>NaN</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A(A==<span class="number">0</span>) = <span class="literal">NaN</span></span><br></pre></td></tr></table></figure><p>把矩陣A中<strong>大於10</strong>的值用<strong>3</strong>來取代</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A((A&gt;<span class="number">10</span>)==<span class="number">1</span>) = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cHM6Ly9nb28uZ2wvQVZzUW1y">Matlab 取代的語法<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;一直忘記，記錄一下。&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="http://natlee.github.io/Blog/categories/develop/"/>
    
    
    <category term="matlab" scheme="http://natlee.github.io/Blog/tags/matlab/"/>
    
    <category term="code" scheme="http://natlee.github.io/Blog/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>MIUI7中WSM/XPOSED Framwork無法使用問題</title>
    <link href="http://natlee.github.io/Blog/posts/1497250561/"/>
    <id>http://natlee.github.io/Blog/posts/1497250561/</id>
    <published>2015-12-19T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p><font color="red">※功能於最新版已修復</font></p><p>相信很多人把MIUI系統從6更新到7時，發現WSM不能使用了。 這個問題跟系統檔案的<strong>app_process</strong>和<strong>libandroid_runtime.so</strong>有關。</p><span id="more"></span><h2 id="步驟說明"><a href="#步驟說明" class="headerlink" title="步驟說明"></a>步驟說明</h2><hr><p><span class="exturl" data-url="aHR0cDovL2VuLm1pdWkuY29tL3RocmVhZC03ODg5NC0xLTEuaHRtbA==">新方法按我<i class="fa fa-external-link-alt"></i></span></p><p><font color="red">※以下為舊方法</font></p><blockquote><p><font color="RED">WSM/Xposed is not (yet) compatible with Android SDK version 19 or your processor architecture (armeabi-v7a).</font></p></blockquote><p>SDK對應的版本為： SDK22 = 5.1 SDK21 = 5.0 SDK19 = 4.4 (KitKat)</p><p>這個修復方法的概念是把新版系統檔案替換成舊版的檔案。</p><ol><li>用<strong>Root Explorer</strong>找到</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/app_process</span><br><span class="line">/system/lib/libandroid_runtime.so</span><br></pre></td></tr></table></figure><ol start="2"><li>把它們備份</li><li>下載舊版<strong>app_process</strong>和<strong>libandroid_runtime.so</strong> <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5kcm9pZGZpbGVob3N0LmNvbS8/ZmlkPTI0MjY5OTgyMDg3MDAxMTU4">點我下載<i class="fa fa-external-link-alt"></i></span></li><li>複製**/System<strong>內</strong>/bin<strong>及</strong>/lib**的檔案貼上到以下位置</li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_process → /system/bin/</span><br><span class="line">libandroid_runtime.so → /system/lib/</span><br></pre></td></tr></table></figure><ol start="5"><li>更改兩個檔案的<strong>permissions</strong></li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_process (-rwxr-xr-x)</span><br><span class="line">libandroid_runtime.so (-rw-r--r--)</span><br></pre></td></tr></table></figure><ol start="6"><li>重啟並安裝<strong>Xposed/WSM</strong></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><hr><p><span class="exturl" data-url="aHR0cDovL2ZvcnVtLnhkYS1kZXZlbG9wZXJzLmNvbS94aWFvbWktbWktMy90aGVtZXMtYXBwcy93c20teHBvc2VkLWZyYW1ld29yay1maXgtY2hpbmVzZS1yb21zLTUtdDMyMjEwMzA=">XDA [wsm/xposed framework fix for all miui roms]<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;※功能於最新版已修復&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;相信很多人把MIUI系統從6更新到7時，發現WSM不能使用了。 這個問題跟系統檔案的&lt;strong&gt;app_process&lt;/strong&gt;和&lt;strong&gt;libandroid_runtime.so&lt;/strong&gt;有關。&lt;/p&gt;</summary>
    
    
    
    <category term="android" scheme="http://natlee.github.io/Blog/categories/android/"/>
    
    
    <category term="android" scheme="http://natlee.github.io/Blog/tags/android/"/>
    
    <category term="miui" scheme="http://natlee.github.io/Blog/tags/miui/"/>
    
    <category term="wsm" scheme="http://natlee.github.io/Blog/tags/wsm/"/>
    
    <category term="xiaomi" scheme="http://natlee.github.io/Blog/tags/xiaomi/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo的主題jacman中使用Disqus</title>
    <link href="http://natlee.github.io/Blog/posts/3977034761/"/>
    <id>http://natlee.github.io/Blog/posts/3977034761/</id>
    <published>2015-08-17T16:00:00.000Z</published>
    <updated>2022-02-10T00:25:59.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>之前裝hexo的時候，留言一直弄不好，還是先記錄一下步驟，以免之後忘記XD</p><span id="more"></span><h2 id="步驟"><a href="#步驟" class="headerlink" title="步驟"></a>步驟</h2><hr><p>先註冊<span class="exturl" data-url="aHR0cHM6Ly9kaXNxdXMuY29tLw==">Disqus<i class="fa fa-external-link-alt"></i></span>帳號並登入到主頁面</p><ol><li><p>點選右上角的選項-&gt;<strong>Add Disqus To Site</strong></p><p> <img src="http://i.imgur.com/LJYmpVy.png"></p></li><li><p>點選<strong>Start Using Engage</strong></p><p> <img src="http://i.imgur.com/w7A8ZVw.png"></p></li><li><p>在<strong>Site name</strong>輸入你要的名字（這裡以<strong>justTryTest</strong>為例）</p><p> <img src="http://i.imgur.com/2x04Lcz.png"></p></li><li><p>按下<strong>Universal Code</strong>，把內容貼至<br><strong>.\themes\jacman\layout_partial\post\comment.ejs</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  &lt;% <span class="keyword">if</span> (theme.disqus_shortname &amp;&amp; page.comments)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ds-thread&quot;</span> <span class="attr">data-thread-key</span>=<span class="string">&quot;&lt;%- page.path %&gt;&quot;</span> <span class="attr">data-title</span>=<span class="string">&quot;&lt;%- page.title %&gt;&quot;</span> <span class="attr">data-url</span>=<span class="string">&quot;&lt;%- page.permalink %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;disqus_thread&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">/* * * CONFIGURATION VARIABLES * * */</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> disqus_shortname = <span class="string">&#x27;justtrytest&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">/* * * DON&#x27;T EDIT BELOW THIS LINE * * */</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> dsq = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>); dsq.type = <span class="string">&#x27;text/javascript&#x27;</span>; dsq.async = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    dsq.src = <span class="string">&#x27;//&#x27;</span> + disqus_shortname + <span class="string">&#x27;.disqus.com/embed.js&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       (<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>]).appendChild(dsq);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)();</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://disqus.com/?ref_noscript&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;nofollow&quot;</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>再到**.\themes\jacman_config.yml**，在最後一行加入</p><pre><code> #### Comment duoshuo_shortname: disqus_shortname: justtrytest</code></pre><blockquote><p>　　<strong>justtrytest</strong>是你在<strong>步驟3</strong>所輸入的名字</p></blockquote></li><li><p>回到剛剛的網頁，按下<strong>Advance</strong></p><p> <img src="http://i.imgur.com/2uH5tyZ.png"></p></li><li><p>在<strong>Trusted Domains</strong>加入自己Blog的位置</p><p> <img src="http://i.imgur.com/Zd2W1zg.png"></p></li><li><p>按下<strong>Save Changes</strong>後，重新啟用Blog即可以啟用Disqus</p></li></ol><h2 id="追記"><a href="#追記" class="headerlink" title="追記"></a>追記</h2><hr><p>安裝時，注意一下站點與theme本身需求的**_config.yml**的配置<br>似乎可以省一些麻煩XD</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;之前裝hexo的時候，留言一直弄不好，還是先記錄一下步驟，以免之後忘記XD&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="http://natlee.github.io/Blog/categories/blog/"/>
    
    
    <category term="hexo" scheme="http://natlee.github.io/Blog/tags/hexo/"/>
    
    <category term="github" scheme="http://natlee.github.io/Blog/tags/github/"/>
    
    <category term="disqus" scheme="http://natlee.github.io/Blog/tags/disqus/"/>
    
    <category term="comment" scheme="http://natlee.github.io/Blog/tags/comment/"/>
    
  </entry>
  
</feed>
